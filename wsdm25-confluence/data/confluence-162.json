{
    "id": "confluence-162",
    "title": "Toolstack - Haskell/OCaml",
    "url": "https://openxt.atlassian.net/wiki/spaces/~rphilipson/pages/21987366/Toolstack+-+Haskell/OCaml",
    "content": "<p>Owned by Ross Philipson\nLast updated: Feb 05, 2016 by Ross Philipson\n\n</p><h1><span class=\"mw-headline\">xec / xec-vm</span></h1><p>These are small haskell programs. Xec is a generic dbus access utility, similar to dbus-send, can be used to communicate with any dbus daemon though defaults to communication with xenmgr. Xec-vm is a wrapper around xec which is vm aware. Both have decent \"--help\" toggles so will not describe their options further.</p><h1><span class=\"mw-headline\">Database daemon</span></h1><p>Database daemon (dbd) is a small ocaml/dbus aplication which handles persistence of xenclient configuration data. The database files are stored in /config/db and /config/vms.</p><p>Dbd reads config files (which are in json format) at startup and creates in-memory representation of the database, which is primarily a simple tree of strings similar to xenstore. From now on it proceeds to work on memory representation only, marking it dirty in case of modifications. The dirty trees are flushed to disk in 3s intervals. Dbd features protection against power cuts / partial writes. It always flushes to temporary file first, then atomically renames the temporary file.</p><h2><span class=\"mw-headline\">API presented by dbd</span></h2><pre>    +  read                         ( path:s, OUT value:s )\n</pre><p>reads a string value at given path</p><pre>    +  read-binary                  ( path:s, OUT value:ay )\n</pre><p>reads byte array value at given path</p><pre>    +  write                        ( path:s, value:s )\n</pre><p>writes string value to given path</p><pre>    +  dump                         ( path:s, OUT value:s )\n</pre><p>dumps whole json subtree at given path</p><pre>    +  inject                       ( path:s, value:s )\n</pre><p>writes whole json subtree to given path</p><pre>    +  list                         ( path:s, OUT value:as )\n</pre><p>lists child nodes at given path</p><pre>    +  rm                           ( path:s )\n</pre><p>removes subtree at given path</p><pre>    +  exists                       ( path:s, OUT ex:b )\n</pre><p>checks if a subtree/value at given path exists</p><h1><span class=\"mw-headline\">RPC proxy</span></h1><p>RPC proxy is a haskell application which supports proxying and filtering of RPC traffic used in xenclient. The proxied traffic consists either of binary dbus (for most use cases) or json/websocket based dbus (for conversations with web browser in uivm) and is transported using unix domain sockets or v4v sockets.</p><p>There are 3 instances of rpc-proxy running by default in dom0, each of them having different function:</p><pre>/usr/bin/rpc-proxy -s\n</pre><p>This one forwards data between default incoming channel (v4v port 5555) to default outgoing channel (unix socket /var/run/dbus/system_bus_socket). The effect is that it's possible for any VM to connect to v4v port 5555 of domain 0 and get access to it's system bus in similar fashion that's possible locally within vm by connecting to the unix socket. V4V port 5555 is exposed only to reasonably trusted service vms, such as ndvm/syncvm since it's possible to export new services on domain dom0 bus by connecting to it. Rpc-proxy makes decision whether to forward or drop messages based on default rules file in /etc/rpc-proxy.rules</p><pre>/usr/bin/rpc-proxy -i v4v:5556 -n com.citrix.xenclient.guest.uuid_$UUID --translate-anonymous-dests\n</pre><p>This one is similar to one above however slightly more \"secure\" and therefore exposed to user vms as well. It forwards data between v4v port 5556 to default outgoing channel (unix socket /var/run/dbus/system_bus_socket). The \"-n com.citrix.xenclient.guest.uuid_$UUID\" arguments causes any attempt to export named service on dom0 to force a rename of the service to com.citrix.xenclient.guest.uuid_$UUID. Therefore a guest connecting to this port can only export one service. This has been useful in the past for implementing an agent in linux vms exporting guest power management operations, but I believe this has since been replaced by xenstore/pv driver based functionality.</p><pre>/usr/bin/rpc-proxy -i v4v:8080 --json-in --websockets-in -n com.citrix.xenclient.guest.uuid_$UUID --auto-auth\n</pre><p>This one listens on v4v port 8080 and forwards to default outgoing channel (unix socket /var/run/dbus/system_bus_socket). It expects incoming data in json format (--json-in) wrapped in websocket protocol (--websockets-in). It limits ability to export service names on dom0 bus via \"-n com.citrix.xenclient.guest.uuid_$UUID\". This is used for communications with browser used in uivm. \"--auto-auth\" is just a shortcut to avoid the browser having to do dbus authentication, rpc-proxy will do it on its behalf (we don't use dbus authentication for any security purposes, all it does is state that we are connecting as root user).</p><h2><span class=\"mw-headline\">RPC rules format</span></h2><p>The default rpc rules are stored in /etc/rpc-proxy.rules file. Extra rules can be attached to vm config trees and will take effect when the VM is started and be torn down when the VM is stopped. The format of the rules is relatively straightforward, by example:</p><pre># nothing can be done by default\ndeny all\n</pre><pre># allow stubdoms to talk to surfman,xenmgr,dbus\nallow stubdom true destination com.citrix.xenclient.surfman\nallow stubdom true destination com.citrix.xenclient.xenmgr\nallow stubdom true destination org.freedesktop.DBus interface org.freedesktop.DBus\n</pre><pre># allow guests to call 'gather' on diagnostics interface (required by xc-diag)\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.diag member gather\n</pre><pre># allow anybody to do some vm queries required for switcher bar\nallow destination com.citrix.xenclient.xenmgr interface org.freedesktop.DBus.Properties member Get\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr member list_vms\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.vm member get_db_key\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.vm member read_icon\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.vm member switch\nallow destination com.citrix.xenclient.input interface com.citrix.xenclient.input member get_focus_domid\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr member find_vm_by_domid\n</pre><pre># allow guest to do some requests\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.guestreq member request_attention\n</pre><pre># allow conditional domstore (private db space) access\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member read if-boolean domstore-read-access true\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member read_binary if-boolean domstore-read-access true\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member list if-boolean domstore-read-access true\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member exists if-boolean domstore-read-access true\n</pre><pre>allow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member write if-boolean domstore-write-access true\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member rm if-boolean domstore-write-access true\n</pre><ul style=\"margin-left: 1.6em;\"><li>Only allow/deny rules are supported. The rule type specification is followed by a dbus message matcher where \"destination &lt;name&gt;\" \"interface &lt;name&gt;\" and \"member &lt;name&gt;\" can be specified to match on the corresponding fields of incoming dbus message.</li></ul><ul style=\"margin-left: 1.6em;\"><li>stubdom rules</li></ul><p>Of some interest are stubdom rules marked as \"stubdom true\". They only match on messages coming from stub domains</p><ul style=\"margin-left: 1.6em;\"><li>rules based on configuration of vm sending the message</li></ul><p>Also it is possible to make rules based on any boolean fields in incoming vm config tree. In the example above \"if-boolean domstore-read-access true\" matches only if the VM which has sent the message has a \"domstore-read-access\" boolean config in its tree set to true. Therefore it is possible to disable/enable VM's domstore access (which boils down to allowing it to access dbd remotely) simply by manipulating its config tree.</p><ul style=\"margin-left: 1.6em;\"><li>rules based on domain type</li></ul><p>Sometimes it's useful to grant rpc permission to all vms of particular type (such as \"ndvm\", \"syncvm\"). This can be achieved by adding \"dom-type &lt;type&gt;\" matcher to the rule, for example:</p><pre>allow dom-type syncvm destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.vm member add_disk\n</pre><h1><span class=\"mw-headline\">xenvm</span></h1><p>xenvm is a single virtual machine monitor, written in Ocaml. It's forked on per-vm basis, and responsible for its lifecycle and control operations. It interacts directly with Xen via libxenctrl wrapper. You can find it in toolstack.git.</p><p><em>Which layers of xenvm have state? If xenvm is killed should the domain die? Can xenvm be restarted while a domain continues running? Should xenvm instances exist for VMs which are not running? - Dickon</em></p><p>Tomaszw: Xenvm is a quite stateful daemon:</p><ul style=\"margin-left: 1.6em;\"><li>upper layers hold the vm config state in memory</li><li>upper layers hold the vm state in memory</li></ul><p>I believe the lower layers (such as xenops / device layer) primarily rely on state stored in xenstore, mostly by pv drivers, and don't hold in-memory state (they do tend to write (and later read) some small extra state bits to xenstore (rarely)).</p><p>It does run even if the VM is not running, providing the configurability of VM in its \"stopped\" state. However, as a boot performance optimization, it's only started for the first time when the 1st request to start a VM it handles is created, then continues to run until system shutdown (or VM deletion). Xenmgr copes with it by delaying the initial configuration.</p><p>The state of VM reported by xenvm is partially taken from domain state reported by xen, partially figured out by xenvm. Xen doesn't report exact domain states when it notifies the dom0 toolstack about a state change (via event channel), it basically just gives a notification that \"something has happened\" and it's the job of xenvm to check on each VM whether it's still running, or died etc and update its internal state accordingly (and then forward it to upper layers of toolstack, that is xenmgr).</p><p>Xenvm cannot be restarted when a domain is running, that is the limitation of how it's coded at the moment (stateful). It can be restarted when domain is dead, but does not automatically quit when domain dies (and shouldn't).</p><h2><span class=\"mw-headline\">Code Layout</span></h2><h3><span class=\"mw-headline\">Libraries</span></h3><ul style=\"margin-left: 1.6em;\"><li>libs/common - various utilities</li><li>libs/eventchn - binding for libxenctrl's eventchannel interfaces</li><li>libs/json - json parser</li><li>libs/stdext - utility extensions for Ocaml's standard library</li><li>libs/uuid - uuid generation and handling</li><li>libs/xc - libxenctrl binding</li><li>libs/xg - libxenguest binding</li><li>libs/xs - native ocaml xenstore protocol implementation</li></ul><h3><span class=\"mw-headline\">Scripts</span></h3><p>There are few udev scripts in \"scripts\" subfolder, as well as udev rules for executing these scripts. These handle the notifications to the toolstack that the backend pv drivers have completed creating network/disk devices, or torn them down.</p><h3><span class=\"mw-headline\">Xenops</span></h3><p>Xenops is the lower-layer part of xenvm, responsible for lower level management of xen domains (via domain ids). It is both used internally by xenvm as well as exposed to the user via the \"xenops\" dom0 utility.</p><ul style=\"margin-left: 1.6em;\"><li>xenops/<a href=\"http://balloon.ml\">balloon.ml</a> - memory ballooning utilities, not used much in xenclient</li><li>xenops/<a href=\"http://device.ml\">device.ml</a> and <a href=\"http://device_common.ml\">device_common.ml</a> - important files which are responsible for initialization of pv (or PCI passthrough) device backends (via xenstore)</li><li>xenops/<a href=\"http://dm.ml\">dm.ml</a> - config construction for qemu</li><li>xenops/<a href=\"http://dmagent.ml\">dmagent.ml</a> - communication with dmagent, which is a program used to fork/configure qemu instances (which can be running in another domain)</li><li>xenops/domain[_common].ml - domain management functions</li><li>xenops/<a href=\"http://hotplug.ml\">hotplug.ml</a> - few utility functions to wait on device being created by pv backend etc</li><li>xenops/<a href=\"http://memory.ml\">memory.ml</a> - crazy arthimetic to figure out how much memory is required to boot a VM</li><li>xenops/<a href=\"http://netman.ml\">netman.ml</a> - couple network helper functions</li><li>xenops/<a href=\"http://watch.ml\">watch.ml</a> - xenstore watch helper functions</li><li>xenops/<a href=\"http://xal.ml\">xal.ml</a> - low level loop waiting and parsing pv device events</li></ul><h3><span class=\"mw-headline\">Xenvm</span></h3><ul style=\"margin-left: 1.6em;\"><li>xenvm/<a href=\"http://misc.ml\">misc.ml</a> - as name says</li><li>xenvm/<a href=\"http://tasks.ml\">tasks.ml</a> - list of rpc tasks xenvm supports</li><li>xenvm/<a href=\"http://vmact.ml\">vmact.ml</a> - high level implementation of vm operations (start/stop etc)</li><li>xenvm/<a href=\"http://vmconfig.ml\">vmconfig.ml</a> - parsing xenvm config files (in xenclient, placed in /tmp/xenmgr-xenvm-*)</li><li>xenvm/<a href=\"http://vmstate.ml\">vmstate.ml</a> - vm state struct</li><li>xenvm/<a href=\"http://xenops.ml\">xenops.ml</a> - xenops dom0 utility entry point</li><li>xenvm/<a href=\"http://xenvm.ml\">xenvm.ml</a> - daemon entry point</li></ul><h1><span class=\"mw-headline\">xenmgr</span></h1><p>xenmgr is a haskell application which exports VM configuration over DBus and translates it to lower level configuration files consumed by xenvm. Since xenvm is a single virtual machine monitor, xenmgr is reponsible for some cross-vm concepts, such as relocating network pv backend on backend domain reboot, vm dependencies, enforcing cross-vm v4v firewall rules etc.</p><p><em>Please detail the concurrency model (e.g. thread per dbus connection, reactor or whatever). What are the consequenes of killing and restarting xenmgr? What normally launches xenmgr? - Dickon</em></p><p>Tomaszw: xenmgr is started by the \"bootage\" dom0 program, similarily to many other dom0 daemons (configured in /etc/bootage.conf). Xenmgr is fully restartible, since it doesn't keep almost any in-memory vm state. The only consequence is a temporary DoS on its functionality, as well as the possibility of some startup code executing again, which includes for example locking the UIVM with authentication screen, or performing boot-time service vm filesystem checksum.</p><p>Each incoming RPC call to xenmgr is processed in parallel (in so called haskell IO thread). Because most of the state is kept outside of xenmgr (either in db, or xenstore), there isn't much synchronisation needed. Still, because the dbd doesn't support transactions, some db writes need to be protected by locking, which xenmgr does.</p><p>Unlike incoming calls, incoming notifications are processed serially on a separate IO thread. This is because the ordering of notifications is important (and guaranteed by dbus, therefore we have to process them serially to keep the guarantee). As a consequence, long running notification handlers should be forking off a thread to not block the queue.</p><h2><span class=\"mw-headline\">Exported DBus entities</span></h2><p>xenmgr exports following dbus objects:</p><ul style=\"margin-left: 1.6em;\"><li>/ - root object, contains global configuration and operations</li><li>/vm/$VM_UUID - per vm dbus object, provides access to vm configuration</li><li>/vm/$VM_UUID/$DISK_ID - provides access to vm disk configuration</li><li>/vm/$VM_UUID/$NIC_ID - provides access to vm network interface configuration</li><li>/host - provides access to host specific configuration and host information</li></ul><p>each of these objects exports one or more dbus interfaces, as defined in IDL repository (idl.git). Following IDL files are used by xenmgr</p><ul style=\"margin-left: 1.6em;\"><li>xenmgr.xml</li><li>xenmgr_vm.xml</li><li>xenmgr_host.xml</li><li>vm_nic.xml</li><li>vm_disk.xml</li></ul><h2><span class=\"mw-headline\">DBus interface boilerplate generation</span></h2><p>Most of dbus boilerplate code, such as the hooks to implement exported functions as well as stubs for calling other daemons is generated from the files in idl.git by a custom written program \"rpcgen\". It takes dbus xml files as input and produces binding/hooks in variety of languages as output.</p><p>In case of xenmgr the boilerplate is generated from its BB recipie, in the configure step:</p><pre>   # generate rpc stubs\n   mkdir -p Rpc/Autogen\n   # Server objects\n   xc-rpcgen --haskell -s -o Rpc/Autogen --module-prefix=Rpc.Autogen ${STAGING_DATADIR}/idl/xenmgr.xml\n   xc-rpcgen --haskell -s -o Rpc/Autogen --module-prefix=Rpc.Autogen ${STAGING_DATADIR}/idl/xenmgr_vm.xml\n</pre><p>Hence usually modification of IDL consists of following steps:</p><ul style=\"margin-left: 1.6em;\"><li>modify IDL files</li><li>restage IDL files (for example by ./bb -cforce_rebuild xenclient-idl &amp;&amp; ./bb xenclient-idl)</li><li>regenerate boilerplate (./bb -cconfigure xenmgr)</li><li>compile xenmgr (./bb -ccompile xenmgr), fix errors, add implementation for new methods etc</li></ul><h2><span class=\"mw-headline\">VM templates</span></h2><p>There's a bunch of json templates in the \"templates\" subfolder; on the device they are installed in /usr/share/xenmgr-1.0/templates. There are basically two types of templates:</p><ul style=\"margin-left: 1.6em;\"><li>service vm template, distinguished via \"service-\" prefix in filename. On each boot, the toolstack will create a VM instance based on these (which will be visible via xec-vm contrl utility). If same instance was already present, it's config will be overwritten each boot, which generally makes for easy upgrades of service vm config files (default ndvm or uivm)</li></ul><ul style=\"margin-left: 1.6em;\"><li>all other templates. VM instances based on these will only be created by manual request (either from UI vm creation wizard, or one of the xec create-vm-* functions)</li></ul><p>It's sometimes handy to turn off the automatic overwrite of service vm templates each xenmgr start, so that the service vm can be reconfigured via manual xec-vm invocations. This can be achieved via</p><pre>db-write /overwrite-&lt;vmtype&gt;-settings false\n</pre><p>for example for ndvm: db-write /overwrite-ndvm-settings false</p><h2><span class=\"mw-headline\">VM configuration</span></h2><p>JSON vm configuration files are stored in /config/vms/ though xenmgr doesn't access them directly but rather through dbd's dbus API. Low level configuration files consumed by xenvm (which are output by xenmgr) reside in /tmp/xenmgr-xenvm-$VM_UUID files.</p><h3><span class=\"mw-headline\">VM properties</span></h3><p>VM properties are declared in idl.git, in interfaces/xenmgr_vm.xml. Most of them are documented, so I won't redo that here. Any additional documention should go to IDL files since that's also the place from which sdk docs are generated.</p><h3><span class=\"mw-headline\">Dodgy VM properties</span></h3><p>There are some vm properties which have non trivial repercussions and warrant additional clarification:</p><ul style=\"margin-left: 1.6em;\"><li>xci-cpuid-signature</li></ul><p>Setting it to true changes CPUID signature reported by xen to be xenclient specific. Effectively it hides xen presence from the guest. We use it on linux VMs to avoid the default PV drivers in upstream kernels from activating (so that we can use custom ones). However toggling it off enables the usage of upstream drivers, if needed.</p><ul style=\"margin-left: 1.6em;\"><li>flask-label</li></ul><p>This specifies the selinux security context under which VM runs, if mismatched it can prevent the VM from being able to issue hypercalls required for its normal function.</p><ul style=\"margin-left: 1.6em;\"><li>provides-network-backend</li></ul><p>Tells xenmgr to treat this vm as network VM; it will send notifications about VM that VM state to network daemon.</p><ul style=\"margin-left: 1.6em;\"><li>greedy-pciback-bind</li></ul><p>This activates the behaviour of greedily seizing devices , which are configured for PCI passhthrough by any vm, by pciback driver on xenclient boot. This behaviour is different from the upstream one, however it is useful to prevent dom0 drivers using the devices which might later be used for passthrough.</p><p>Audio driver is a good example; if audio card is not seized by pciback driver at boot, alsa drivers in dom0 will take over it which might prevent passthrough from working correctly later when PCI passthrough vm is started.</p><h3><span class=\"mw-headline\">VM hooks</span></h3><p>xenmgr supports offloading some of its functionality to either a script, or another dbus daemon (possibly running in different vm). This is done via the following VM hooks (implemented as regular vm properties):</p><ul style=\"margin-left: 1.6em;\"><li>run-post-create</li><li>run-pre-delete</li><li>run-pre-boot</li><li>run-insteadof-start</li><li>run-on-state-change</li><li>run-on-acpi-state-change</li></ul><p>Each hook can be either a script name, example:</p><pre>xec-vm -n foo set run-insteadof-start /bin/customstart\n</pre><p>or a string specifying dbus rpc call to make, example:</p><pre>xec-vm -n foo set run-insteadof-start rpc:vm=$SOME_UUID,destination=com.citrix.some.service,interface=com.citrix.iface,member=com.citrix.some.method\n</pre><p>both the script and rpc call gets passed the affected VM uuid as its single argument.</p><h3><span class=\"mw-headline\">PCI passthrough rules</span></h3><p>VM passthrough rules are specified by a set of matchers, which are evaluated when VM starts to find actual PCI devices which need to be PT-ed.</p><p>VM PCI passthrough rules are managed by the following dbus methods:</p><ul style=\"margin-left: 1.6em;\"><li>add_pt_rule &lt;pciclass&gt; &lt;pcivendor&gt; &lt;pcidevice&gt;</li></ul><p>Adds a new passthrough rules. each of the &lt;pciclass&gt; &lt;pcivendor&gt; &lt;pcidevice&gt; matchers can take either an ID or word \"any\" which means match on all devices. example:</p><pre>xec -n somevm add-pt-rule 0x680 any any\n</pre><ul style=\"margin-left: 1.6em;\"><li>add_pt_rule_bdf &lt;bdf&gt;</li></ul><p>Adds a new passthrough rule using BDF notation, example:</p><pre>xec -n somevm add-pt-rule-bdf 0000:00:16.0\n</pre><ul style=\"margin-left: 1.6em;\"><li>delete_pt_rule, delete_pt_rule_bdf - removal of passthrough rules</li><li>list_pt_rules - lists current passthrough rules</li><li>list_pt_pci_devices - evaluates all vm passthrough rules and outputs lists of matching pci devices on host</li></ul><h3><span class=\"mw-headline\">V4V firewall rules</span></h3><p>V4V firewall rules are managed by dbus api similarily to PCI passthrough rules and evaluated when the VM starts. They usually result in a series of calls to \"viptables\" commandline program to erect the firewall. On VM shutdowns, the entries added during VM start are torn down.</p><p>V4V firewall rules can be modified via add_v4v_firewall_rule / delete_v4v_firewall_rule methods. These take a string argument with a rule definiton. The format of rule string is as follows:</p><pre>&lt;source&gt; -&gt; &lt;destination&gt;\n</pre><p>the format of each of the source/destination endpoints is</p><pre>( * | my-stubdom | myself | dom-type=&lt;domaintype&gt; | dom-name=&lt;domainname&gt; ) : &lt;v4v port&gt;\n</pre><p>examples:</p><ul style=\"margin-left: 1.6em;\"><li>open connection from the VM to domain's 0 port 5555: myself-&gt; 0:555</li><li>open connection from the VM to all domains of type \"ndvm\" port 5555: myself -&gt; dom-type=ndvm:5555</li><li>open connection from VM's stubdom to domain 0 port 333: my-stubdom -&gt; 0:333</li></ul><h2><span class=\"mw-headline\">VM measurement</span></h2><p>Before VM is started, if it has \"measured\" property set, the first disk (with ID of 0), and only the first disk, will be checked for checksum consistency with a hash stored in vm config tree. This is done by mounting the filesystem and computing sha256 hash of the filesystem (as opposed to doing it on VHD file; because even readonly VHD files are modified due some bookkeep information such as access timestamp).</p><p>If a hash inconsistency is detected, a measurement failure action will be invoked. It defaults to shutting down the system. It can be overriden via</p><pre>db-write /xenmgr/measure-fail-action &lt;powermanagementaction&gt;\n</pre><p>&lt;powermanagementaction&gt; can be one of the following</p><ul style=\"margin-left: 1.6em;\"><li>sleep</li><li>hibernate</li><li>shutdown</li><li>forced-shutdown</li><li>reboot</li><li>nothing</li></ul><p>and as said previously, defaults to forced shutdown if not specified</p><h2><span class=\"mw-headline\">VM dependencies</span></h2><p>xenmgr supports simple form of dependency tracking between vms. If a VM is configured such that its network backend is not in dom0, xenmgr will internally track that dependency. It's possible to list all the vms a given vm depends on by</p><pre>xec-vm -n somevm list-dependencies\n</pre><p>By default when a VM is started, xenmgr will ensure all its dependecies are started first. This can be toggled off via setting \"track-dependencies\" vm property to false.</p><p>There's no automatic shutdown of dependent vms.</p><h2><span class=\"mw-headline\">Power Management</span></h2><p>Xenmgr supports some configuration of power related operations</p><ul style=\"margin-left: 1.6em;\"><li>vm property \"s3-mode\"</li></ul><p>This configures how the toolstack handles requests to put a VM to S3. Note that this doesn't affect requests made from within guest, but just requests originating from the UI / closing the laptopt lid etc. It can be one of the following:</p><ul style=\"margin-left: 1.6em;\"><li><ul style=\"margin-left: 1.6em;\"><li>ignore - request to put vm to S3 will be ignored, toolstack will proceed to next vm on the list</li><li>pv - toolstack will ask the PV driver within the guest to put it to S3 via xenstore. This is the default for most vms</li><li>restart - toolstack will shutdown the VM and start it again after S3 resume. This is useful for NDVM.</li></ul></li></ul><ul style=\"margin-left: 1.6em;\"><li>vm property \"s4-mode\"</li></ul><p>Supports exactly same configurability as \"s3-mode\", specifies actions to be taken when toolstack is supposed to put VM to hibernate.</p><ul style=\"margin-left: 1.6em;\"><li>vm property \"control-platform-power-state\"</li></ul><p>This is useful for some single-vm scenarios. Toolstack will track guest power state and try to put host to the same state. So if the guest goes to S3, toolstack will put the host to S3 as well.</p><ul style=\"margin-left: 1.6em;\"><li>host methods \"set_ac_lid_close_action\", \"set_battery_lid_close_action\"</li></ul><p>Configure the power action performed when laptop lid closes, either on battery or AC adapter. Can be one of the following:</p><ul style=\"margin-left: 1.6em;\"><li>sleep</li><li>hibernate</li><li>shutdown</li><li>forced-shutdown</li><li>reboot</li><li>nothing</li></ul><h2><span class=\"mw-headline\">Code layout</span></h2><p>Xenmgr is split into a small library (xenmgr-core) and main daemon (xenmgr). xenmgr-core atm contains very little, primarily just a bit of v4v firewall rule parsing code. The intent was to move code useful for other projects (such as the OVF import tool) out of xenmgr daemon and into the library.</p><h3><span class=\"mw-headline\">Custom Libraries Used</span></h3><p>There's a bunch of small haskell libraries we wrote which are in use by toolstack components. They reside in xclibs.git.</p><ul style=\"margin-left: 1.6em;\"><li>udbus - vincent's small dbus library</li><li>xchv4v - v4v access library</li><li>xch-rpc - higher level rpc library based on udbus, also with support for v4v rpc tunnels</li><li>xchdb - access to database files in /config, thru database daemon</li><li>xchutils - various random useful utility code</li><li>xchwebsocket - websocket library used by rpc-proxy</li></ul><h3><span class=\"mw-headline\">xenmgr-core</span></h3><ul style=\"margin-left: 1.6em;\"><li>Vm/Uuid.hs - few functions related to handling UUIDs</li><li>Vm/ProductProperty.hs - handling OVF product properties (not used much atm besides theoretically for vms defined by OVF xml)</li><li>Vm/V4VFirewall.hs - parsing of v4v firewall rules</li></ul><h3><span class=\"mw-headline\">xenmgr</span></h3><ul style=\"margin-left: 1.6em;\"><li>Rpc/Autogen - folder containing all rpc access stubs generated by rpcgen (invoked from bb recipie)</li><li>Tools/* - various utility code</li></ul><h4><span class=\"mw-headline\">Vm subtree</span></h4><ul style=\"margin-left: 1.6em;\"><li>Vm/Types.hs - definition of important types, such as definition of vm config and vm states</li><li>Vm/Monad.hs - definition of \"Vm\" monad which is a simple reader-based monad which implicitly holds context for single vm</li><li>Vm/Config.hs - definition of database location for all vm config properties and code to create lower-level xenvm config files</li><li>Vm/State.hs - vm state conversions from/to string as well as introduction of concept of internal vm state, which is a vm state private to xenmgr and more detailed than the generic state exposed from xenvm</li><li>Vm/Dm.hs, DmTypes.hs - types relating to device model, such as disks, nics, xenstore device states, handling backend/frontend interactions</li><li>Vm/DomainCore.hs - handling domids/lookup of domains and their stubdoms</li><li>Vm/Balloon.hs - balloning service vm memory down (if allowed by vm config, which it's usually not)</li><li>Vm/Pci*.hs - PCI passthrough - parsing pci passthrough rules, handling of binding drivers to pciback</li><li>Vm/DepGraph.hs - few graphing utilities to solve the dependency graph between vms (even though it usually boils down to 2 node graphs...)</li><li>Vm/Policies.hs - storage and query of vm policy settings</li><li>Vm/Monitor.hs - code for monitoring vm events from various sources (xenvm and xenstore) and registering/invoking internal handlers</li><li>Vm/React.hs - event handlers for vm events coming from Monitor.hs</li><li>Vm/Templates.hs - finding, categorizing, reading vm and service vm templates (in /usr/share/xenmgr-1.0/templates)</li><li>Vm/Queries.hs - many passive functions to query about vm states/config. Of particular interest would be \"getVmConfig\" functions which creates in-memory config representation based on database</li><li>Vm/Actions.hs - active functions for changing vm config as well as doing some runtime state manipulation (such as relocating network backend to different ndvm), starting/stopping vms etc</li></ul><h4><span class=\"mw-headline\">XenMgr subtree</span></h4><ul style=\"margin-left: 1.6em;\"><li>XenMgr/Connect/* - wrappers to access other daemons in the system</li><li>XenMgr/Expose/* - entry points for all xenmgr's dbus server rpcs</li><li>XenMgr/CdLock.hs - relatively new code for handling the AFRL request cd drive lock model</li><li>XenMgr/Config.hs - global xenmgr config storage/query</li><li>XenMgr/Diagnostics.hs - gathering status reports from vms + other diagnostics</li><li>XenMgr/Diskmgr.hs - vhd creation</li><li>XenMgr/Errors.hs - definition of numbered errors reported to the UI</li><li>XenMgr/Host.hs - lots of host level query functions (eth0 mac adreeses, bios versions, xc versions, update state etc)</li><li>XenMgr/HostOps.hs - host shutdown/slee/hibernate/reboot entry points</li><li>XenMgr/PowerManagement.hs - actual implementation of host shutdown/sleep/hibernate/reboot etc plus code to handle lid state changes</li><li>XenMgr/Notify.hs - wrappers for easier generation of various dbus signals</li><li>XenMgr/Rpc.hs - definition of Rpc monad used in xenmgr for dbus access</li><li>XenMgr/XM.hs - definition of XM monad based on reader monad containing context for _all_ vms. Useful for doing some cross vm interactions which require locking / synchronization</li></ul><h2><span class=\"mw-headline\">Interactions with other daemons</span></h2><p><em>Please specify kind of interaction, e.g. exec, sockets, DBUS, etc - Dickon</em></p><p>xenmgr interacts with the following daemons on system:</p><ul style=\"margin-left: 1.6em;\"><li>database daemon (dbd) for config storage. Via DBUS only.</li><li>xenvm for all low level vm operations / domain creation / shutdown etc. Via DBUS and textual vm config files in /tmp/xenmgr-xenvm-$UUID</li><li>input daemon for handling on-boot authentication screen, vm focus switching, screen lock, seamless mouse configuration. Via DBUS.</li><li>network daemon to notify it about state for vms marked with \"provides-network-backend\" property. Via DBUS (over v4v into network domain)</li><li>surfman to query it for list of passthrough GPU devices if using PVMs (\"get_vgpu_mode\" surfman RPC). Via DBUS.</li></ul><p> </p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "~rphilipson"
}