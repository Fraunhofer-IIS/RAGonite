{
    "id": "confluence-102",
    "title": "XCPMD Policy",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/18612227/XCPMD+Policy",
    "content": "<p>Owned by Jennifer Temkin\nLast updated: Nov 30, 2015 by Jennifer Temkin\n\n</p><ac:structured-macro ac:macro-id=\"2efc2ad9-d711-4d5b-8ad0-63dbeaa3c108\" ac:name=\"info\" ac:schema-version=\"1\"><ac:rich-text-body><p><ac:image ac:width=\"80\"><ri:attachment ri:filename=\"cc-by.png\"></ri:attachment></ac:image></p><p>Copyright 2015 by Assured Information Security, Inc. Created by Jennifer Temkin &lt;temkinj@<a href=\"http://ainfosec.com\">ainfosec.com</a>&gt;. This work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy of this license, visit <a class=\"external-link\" href=\"http://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\">http://creativecommons.org/licenses/by/4.0/</a>.</p></ac:rich-text-body></ac:structured-macro><p><ac:structured-macro ac:macro-id=\"b6bea005-c882-486f-8d88-eaadf09545d4\" ac:name=\"toc\" ac:schema-version=\"1\"></ac:structured-macro></p><h1>Overview</h1><p><span style=\"font-size: 14.0px;line-height: 1.4285715;\">The power management policy consists of a set of rules, and variables that can be used as arguments in these rules. Policy can currently be loaded from a text file, the DB, or added a rule or variable at a time over DBus. All policy, regardless of origin, is ultimately made persistent by storing it in the DB. </span></p><h1><span style=\"font-size: 24.0px;line-height: 1.25;\">Rule Structure</span></h1><p><span style=\"font-size: 24.0px;line-height: 1.25;\"> </span><span style=\"line-height: 1.4285715;\">A rule consists of a name, a set of conditions, a set of actions, and optionally a set of undo actions. When all conditions become true, the rule becomes active, and its actions are executed in order. When any condition becomes untrue, the rule becomes inactive, and its undo actions (if any) are executed in order.</span></p><h2><span style=\"line-height: 1.4285715;\"> </span><span style=\"font-size: 20.0px;line-height: 1.5;\">Name</span></h2><p><span style=\"font-size: 20.0px;line-height: 1.5;\"> </span><span style=\"line-height: 1.4285715;\">Each rule is uniquely identified by its name. This name may be used to later modify or remove a rule. A name may consist of letters, numbers, and underscores.</span></p><p><span style=\"line-height: 1.4285715;\"> </span><span style=\"line-height: 1.4285715;\">Name uniqueness is strictly enforced; attempts to add a rule with the same name as a currently loaded rule will fail.</span></p><h2><span style=\"line-height: 1.4285715;\"> </span><span style=\"font-size: 20.0px;line-height: 1.5;\">Conditions</span></h2><p>A rule’s conditions are a set of Boolean functions that determine when a rule is active. A condition either checks the state of the system or listens for an event. Each condition is individually simple, but more complex rules can be built out of multiple conditions. Multiple conditions are logically ANDed together; therefore, all conditions must be true for a rule to be active. Conditions may be preceded with an exclamation point (!) to invert their return value. If a logical OR is required, consider splitting the conditions into multiple rules with the same actions.</p><p><span style=\"line-height: 1.4285715;\">Conditions are able to be selected from a predefined list of condition types, which are enumerated in the Available Conditions section. A condition resembles a C-like function, with a name followed by an open-close pair of parentheses that may contain arguments, according to the condition type’s prototype. Every condition type has a prototype that defines what arguments, if any, it requires. For example, whileBattLessThan() takes two integers as an argument, representing the battery number to check and the percentage to compare to, whereas whileOnBatt() takes no arguments at all. Each condition is separated with spaces, and each argument within each condition is also separated by spaces.</span></p><p><span style=\"line-height: 1.4285715;\"> </span><span style=\"line-height: 1.4285715;\">See the Arguments section for specific details on arguments.</span></p><h2><span style=\"line-height: 1.4285715;\"> </span><span style=\"font-size: 20.0px;line-height: 1.5;\">Actions</span></h2><p><span style=\"font-size: 20.0px;line-height: 1.5;\"> </span><span style=\"line-height: 1.4285715;\">A rule’s actions dictate what a rule will do when it changes from inactive to active. Actions, as their name implies, perform some sort of task, such as pausing a VM or printing a message to the system log. Each action in the list is performed, one at a time, in the order that they are written in the rule’s set of actions.</span></p><p><span style=\"line-height: 1.4285715;\"> </span><span style=\"line-height: 1.4285715;\">Much like conditions, each action has a defined prototype determining what arguments it takes. Unlike conditions, however, actions do not evaluate to any particular value; therefore, actions and conditions are in no way interchangeable. Actions, like conditions, also consist of a name followed by a set of parentheses that may contain arguments according to a prototype. When arguments are present, they are separated by spaces. Actions themselves are also separated by spaces.</span></p><h2><span style=\"line-height: 1.4285715;\"> </span><span style=\"font-size: 20.0px;line-height: 1.5;\">Undo Actions</span></h2><p><span style=\"font-size: 20.0px;line-height: 1.5;\"> </span><span style=\"line-height: 1.4285715;\">Undo actions are performed when a rule changes from active to inactive, but otherwise, the same conventions apply as in the action section. Undo actions may consist of any set of actions. Undo actions are optional, and may be omitted entirely.</span></p><h2><span style=\"line-height: 1.4285715;\"> </span><span style=\"font-size: 20.0px;line-height: 1.5;\">Arguments</span></h2><p><span style=\"font-size: 20.0px;line-height: 1.5;\"> </span><span style=\"line-height: 1.4285715;\">Arguments are pieces of data provided to conditions and actions. Each argument has a type, which is inferred by the parser. XCPMD currently supports four argument types: </span></p><ul><li><span style=\"line-height: 1.4285715;\">strings, which are enclosed in double-quotes (“); </span></li><li><span style=\"line-height: 1.4285715;\">booleans, which are an unquoted true or false;</span></li><li><span style=\"line-height: 1.4285715;\">floats, which are numbers containing a decimal point; and</span></li><li><span style=\"line-height: 1.4285715;\">integers, which are numbers that do not contain decimal points.</span></li></ul><p><span style=\"line-height: 1.4285715;\">There is no type-punning; an integer cannot be substituted for a float, even if their values are equivalent.</span></p><h2><span style=\"line-height: 1.4285715;\"> </span><span style=\"font-size: 16.0px;font-weight: bold;line-height: 1.5;\">Example Rule</span></h2><p>The following example shows a simple rule with each section separated by pipes (|):</p><ac:structured-macro ac:macro-id=\"ea3c327b-af51-4b0c-b8fc-90461cd5b852\" ac:name=\"code\" ac:schema-version=\"1\"><ac:plain-text-body><![CDATA[rule1 | whileOnBatt() whileBattLessThan(0 30) | logString(“Pausing VM!”) pauseVm(“ubuntu”) | unpauseVm(“ubuntu”)]]></ac:plain-text-body></ac:structured-macro><p><span style=\"line-height: 1.4285715;\">This rule breaks down as follows:</span></p><ul><li><p>The rule’s name is rule1.</p></li><li><p><span style=\"line-height: 1.4285715;\">It will become active while it is both on battery power, and battery 0 has less than 30% capacity remaining. When either of these conditions become false, the rule will be inactive.</span></p></li><li><p><span style=\"line-height: 1.4285715;\">When the rule changes from inactive to active, it will print the string “Pausing VM!” to the system log, then pause the VM named “ubuntu.”</span></p></li><li><p><span style=\"line-height: 1.4285715;\">When the rule changes from active to inactive, it will unpause the VM named “ubuntu.”</span></p></li></ul><p> </p><h2><span style=\"font-size: 20.0px;line-height: 1.5;\">Variables</span></h2><p> </p><p>XCPMD also supports variables. Variables are, essentially, arguments whose values can arbitrarily substituted for other values of the same type, serving as an argument to one or more conditions and/or actions. Unlike constant arguments, the value of variables may change even while the daemon is running.</p><p><span style=\"line-height: 1.4285715;\">In a text file, variables are defined, one per line, using the syntax “varName(value).” For example, the line “batteryLow(20)” defines a variable named batteryLow, whose value is 20, and whose type is inferred as integer. Once defined, variables can be used in rules by referring to them with a dollar sign ($). Our variable could be used in a rule like so:</span></p><ac:structured-macro ac:macro-id=\"0a98190b-4b1e-4e14-812d-5ea8d7aa7ad7\" ac:name=\"code\" ac:schema-version=\"1\"><ac:plain-text-body><![CDATA[rule2 | whileBattLessThan(0 $batteryLow) | logString(“Battery getting low!”)]]></ac:plain-text-body></ac:structured-macro><p>This rule simply prints the message “Battery getting low!” to the system log when battery 0’s remaining capacity drops below 20%.</p><p><span style=\"line-height: 1.4285715;\">Later, if we decide we’d rather have a low battery alert at 10% instead, we can overwrite $batteryLow without having to modify any rules that refer to it.</span></p><p><span style=\"line-height: 1.4285715;\">Variables have a few restrictions:</span></p><ul><li><p>All variables must have unique names.</p></li><li><p>Names may contain only letters, numbers, and underscores (_).</p></li><li><p>A variable must be defined before it can be used in a rule.</p></li><li><p>They are strictly typed, like all arguments. A variable’s type must match the action/condition prototype in order to be used as an argument to that action/condition.</p></li><li><p>Once defined, their type may not change, unless they are deleted and re-added.</p></li><li><p>Variables may not be deleted if they are still in use by any rule.</p></li></ul><h1><span style=\"font-size: 24.0px;line-height: 1.25;\">Configuring Policy</span></h1><p>XCPMD supports three interfaces for configuring policy: text files, DBus, and direct DB modification.</p><h2><span style=\"font-size: 20.0px;line-height: 1.5;\">Text Files</span></h2><p>Text files provide an easy way to encapsulate policy and deploy to many machines. Their syntax is simple and straightforward. Each policy file is broken into two sections, variables and rules, which are separated by a single line containing only an equals sign (=).</p><p>Variables are defined, one per line, with the variable’s name followed by its value within parentheses:</p><ac:structured-macro ac:macro-id=\"697c8a0a-b98d-4754-b7d0-bff69c153661\" ac:name=\"code\" ac:schema-version=\"1\"><ac:plain-text-body><![CDATA[var_name(“value”)]]></ac:plain-text-body></ac:structured-macro><p>Rules are defined, one per line, with the four sections described above separated by pipe characters (|):</p><ac:structured-macro ac:macro-id=\"5c0e502f-0a03-488a-a85a-c866e845967d\" ac:name=\"code\" ac:schema-version=\"1\"><ac:plain-text-body><![CDATA[name | conditions | actions | undo_actions]]></ac:plain-text-body></ac:structured-macro><p>A policy file may also contain comments. Any line beginning with a pound sign (#) will be interpreted as a comment and ignored by the parser. Currently, comments at the end of a line are not supported.</p><p>To trigger loading policy from a text file, use the DBus call load_policy_from_file.</p><ac:structured-macro ac:macro-id=\"1917239b-296c-4612-95bf-784ae5244d61\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"firstline\">1</ac:parameter><ac:parameter ac:name=\"title\">Sample Policy File</ac:parameter><ac:parameter ac:name=\"linenumbers\">true</ac:parameter><ac:plain-text-body><![CDATA[#begin variables section\nubuntu_uuid(“12345678-1234-1234-1234-123456789012”)\nbattery_low(20)\nbattery_critical(7)\n=\n#begin rules section\nscreen_off     | whileLidClosed() | runScript(“/home/user/blank_screen.sh”) | runScript(“/home/user/unblank_screen.sh”)\nlow_batt_alert | whileBattLessThan(0, $battery_low) | logString(“Battery low!”)\npause_ubuntu   | whileBattLessThan(0, $battery_critical) | pauseVmUuid($ubuntu_uuid) | resumeVmUuid($ubuntu_uuid)]]></ac:plain-text-body></ac:structured-macro><h2>DBus Interface</h2><p>XCPMD’s DBus interface allows the user to control and query different aspects of policy. This is the interface that any UI tools would use to modify policy in XCPMD. The following calls are currently available:</p><table><tbody><tr><td><p class=\"NewStyle17\">RPC Name</p></td><td><p class=\"NewStyle17\">Inputs</p></td><td><p class=\"NewStyle17\">Outputs</p></td><td><p class=\"NewStyle17\">Description</p></td></tr><tr><td><p class=\"NewStyle17\">add_rule</p></td><td><p class=\"NewStyle17\">string name<br/><span style=\"line-height: 1.4285715;\">string conditions<br/></span><span style=\"line-height: 1.4285715;\">string actions<br/></span><span style=\"line-height: 1.4285715;\">string undo_actions</span></p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">Adds a rule to the policy.</p></td></tr><tr><td><p class=\"NewStyle17\">remove_rule</p></td><td><p class=\"NewStyle17\">string rule_name</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">Deletes a rule from the policy.</p></td></tr><tr><td><p class=\"NewStyle17\">add_var</p></td><td><p class=\"NewStyle17\">string name<br/><span style=\"line-height: 1.4285715;\">string value</span></p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">Adds a variable to the policy.</p></td></tr><tr><td><p class=\"NewStyle17\">remove_var</p></td><td><p class=\"NewStyle17\">string name</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">Deletes a variable from the policy.</p></td></tr><tr><td><p class=\"NewStyle17\">load_policy_from_db</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">Reloads the policy from the DB.</p></td></tr><tr><td><p class=\"NewStyle17\">load_policy_from_file</p></td><td><p class=\"NewStyle17\">string filename</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">Loads policy from a text file.</p></td></tr><tr><td><p class=\"NewStyle17\">clear_policy</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">Deletes all rules and variables.</p></td></tr><tr><td><p class=\"NewStyle17\">clear_rules</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">Deletes all rules.</p></td></tr><tr><td><p class=\"NewStyle17\">clear_vars</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">Deletes all variables.</p></td></tr><tr><td><p class=\"NewStyle17\">get_conditions</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">string conditions</p></td><td><p class=\"NewStyle17\">Gets a list of available conditions.</p></td></tr><tr><td><p class=\"NewStyle17\">get_actions</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">string actions</p></td><td><p class=\"NewStyle17\">Gets a list of available actions.</p></td></tr><tr><td><p class=\"NewStyle17\">get_rules</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">string rules</p></td><td><p class=\"NewStyle17\">Gets the list of currently loaded rules.</p></td></tr><tr><td><p class=\"NewStyle17\">get_vars</p></td><td><p class=\"NewStyle17\">-</p></td><td><p class=\"NewStyle17\">string vars</p></td><td><p class=\"NewStyle17\">Gets the list of currently loaded variables.</p></td></tr></tbody></table><h3><span style=\"font-size: 16.0px;font-weight: bold;line-height: 1.5;\">DBus Examples</span></h3><p>The dbus-send application provides a convenient way to issue calls on DBus:</p><ac:structured-macro ac:macro-id=\"205ab31b-ce98-4058-b7a0-107e37291f2c\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">bash</ac:parameter><ac:plain-text-body><![CDATA[# Get a list of available condition types and their prototypes:\ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.get_conditions\n \n# Add a rule that prints a message when a laptop is unplugged:\ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.add_rule \\\n    string:’unplug_alert’ \\\n    string:’whileUsingBatt()’ \\\n    string:’logString(“Disconnected from AC power!”)’ \\\n    string:’’\n \n# Add a variable named battery_critical whose value is 7\ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.add_var \\\n    string:’battery_critical’ \\\n    string:’7’\n \n# Add a variable named critical_message whose value is “battery critical!”\ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.add_var \\\n    string:’critical_message’ \\\n    string:’”battery critical!”’\n \n# Print out all variables currently loaded--the two we added should be there\ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.get_vars\n \n# Add a rule using the two variables we added\ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.add_rule \\\n    string:’warn_critical’ \\\n    string:’whileBattLessThan(0, $battery_critical)’ \\\n    string:’logString($critical_message)’ \\\n    string:’’\n \n# Delete the rules we added\ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.remove_rule \\\n    string:’warn_critical’\ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.remove_rule \\\n    string:’unplug_alert’ \n \n# Delete the variables we added \ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.remove_var \\\n    string:’battery_critical’\ndbus-send --system --print-reply --dest=com.citrix.xenclient.xcpmd / com.citrix.xenclient.xcpmd.remove_var \\\n    string:’critical_message’]]></ac:plain-text-body></ac:structured-macro><p>More information on dbus-send is available at <a href=\"http://dbus.freedesktop.org/doc/dbus-send.1.html\">http://dbus.freedesktop.org/doc/dbus-send.1.html</a>.</p><h2><span style=\"font-size: 20.0px;line-height: 1.5;\">DB Modification</span></h2><p>XCPMD uses the DB as a backing store for all policy, and it is possible to modify the DB directly in order to effect policy changes. However, XCPMD does not receive notice of these changes directly, and it is possible for its internal knowledge of policy to become inconsistent if the policy stored in the DB is modified while it is running. Therefore, it is strongly recommended that the DB only be modified directly when XCPMD is not running.</p><p>Modifying the DB directly also bypasses the validity checking performed by XCPMD, so great care should be taken in order to avoid writing invalid policy to the DB. Whenever possible, it is strongly recommended to use the DBus or text file interfaces instead.</p><p>If the DB must be modified while XCPMD is running, it is essential to call load_db_policy on DBus after the modification to trigger a policy refresh.</p><p>Policy is stored in the following structure:</p><ac:structured-macro ac:macro-id=\"520ad2e9-d091-471c-9cab-955a83f99cea\" ac:name=\"code\" ac:schema-version=\"1\"><ac:plain-text-body><![CDATA[/power-management\n  vars\n    var_name1: “value1”\n    var_name2: “value2”\n  rules\n    rule1\n      conditions\n        0\n          type: “whileBattLessThan\"\n          is_inverted: “false”\n          args\n            0: “0”\n            1: “70”\n        1\n          type: “whileUsingBatt”\n          is_inverted: “true”\n          args: “”\n      actions\n        0\n          type: “logString”\n          args\n            0: “\\“On AC power and battery is less than 70%\\””\n      undos\n        0\n          type: “logString”\n          args\n            0: “\\“Either on battery power, or battery is greater than or equal to 70%, or both\\””]]></ac:plain-text-body></ac:structured-macro><p>All DB entries are stored and retrieved as key-value pairs, with both key and value being strings. XCPMD parses the strings retrieved from the DB in the same way as other interfaces, so the same rules apply with respect to argument and variable type inference. In particular, ensure that string-type arguments and variables are wrapped in double quotes--using backslash (\\) as an escape character may be necessary, depending on your shell.</p><h2>Parse Errors</h2><p>If the parser is unable to fully parse a rule, it will attempt to salvage as much as it can. An unparseable or invalid condition or action will be discarded, and provided that the rule has at least one remaining condition and at least one remaining action, it will continue to be loaded.</p><p>The complete list of criteria for a valid rule are as follows:</p><ul><li>The rule’s name must be unique</li><li>At least one valid condition:<ul><li>Condition type is known</li><li>Arguments provided match prototype</li><li>All variables are defined</li></ul></li><li>At least one valid action:<ul><li>Action type is known</li><li>Arguments provided match prototype</li><li>All variables are defined</li></ul></li></ul><h1>Available conditions</h1><table><tbody><tr><td><p class=\"NewStyle17\">Condition</p></td><td><p class=\"NewStyle17\">Description</p></td></tr><tr><td><p class=\"NewStyle17\">onBacklightDownBtn(void)</p></td><td><p class=\"NewStyle17\">True briefly when the backlight down button is pressed.</p></td></tr><tr><td><p class=\"NewStyle17\">onBacklightUpBtn(void)</p></td><td><p class=\"NewStyle17\">True briefly when the backlight up button is pressed.</p></td></tr><tr><td><p class=\"NewStyle17\">onPowerBtn(void)</p></td><td><p class=\"NewStyle17\">True briefly when the power button is pressed.</p></td></tr><tr><td><p class=\"NewStyle17\">onSleepBtn(void)</p></td><td><p class=\"NewStyle17\">True briefly when the sleep button is pressed.</p></td></tr><tr><td><p class=\"NewStyle17\">onSuspendBtn(void)</p></td><td><p class=\"NewStyle17\">True briefly when the suspend button is pressed.</p></td></tr><tr><td><p class=\"NewStyle17\">whileLidClosed(void)</p></td><td><p class=\"NewStyle17\">True as long as the laptop lid is closed.</p></td></tr><tr><td><p class=\"NewStyle17\">whileLidOpen(void)</p></td><td><p class=\"NewStyle17\">True as long as the laptop lid is open, or if the system has no lid.</p></td></tr><tr><td><p class=\"NewStyle17\">whileUsingAc(void)</p></td><td><p class=\"NewStyle17\">True as long as the system is plugged into AC power.</p></td></tr><tr><td><p class=\"NewStyle17\">whileUsingBatt(void)</p></td><td><p class=\"NewStyle17\">True as long as the system is running solely on batteries.</p></td></tr><tr><td><p class=\"NewStyle17\">whileInTabletMode(void)</p></td><td><p class=\"NewStyle17\">True as long as the system is in tablet mode.</p></td></tr><tr><td><p class=\"NewStyle17\">whileBattLessThan(int battNum, int percentage)</p></td><td><p class=\"NewStyle17\">True as long as the specified battery’s remaining capacity is less than the specified percentage.</p></td></tr><tr><td><p class=\"NewStyle17\">whileBattEqualTo(int battNum, int percentage)</p></td><td><p class=\"NewStyle17\">True as long as the specified battery’s remaining capacity is equal to the specified percentage.</p></td></tr><tr><td><p class=\"NewStyle17\">whileBattPresent(int battNum)</p></td><td><p class=\"NewStyle17\">True as long as the specified battery is present.</p></td></tr><tr><td><p class=\"NewStyle17\">whileOverallBattGreaterThan(int percentage)</p></td><td><p class=\"NewStyle17\">True when the aggregate capacity of all batteries is greater than the specified percentage.</p></td></tr><tr><td><p class=\"NewStyle17\">whileOverallBattLessThan(int percentage)</p></td><td><p class=\"NewStyle17\">True when the aggregate capacity of all batteries is less than the specified percentage.</p></td></tr><tr><td><p class=\"NewStyle17\">whileOverallBattEqualTo(int percentage)</p></td><td><p class=\"NewStyle17\">True when the aggregate capacity of all batteries is equal to the specified percentage.</p></td></tr><tr><td><p class=\"NewStyle17\">whenAnyVmCreating(void)</p></td><td><p class=\"NewStyle17\">True briefly when any VM enters the “creating” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenAnyVmStopping(void)</p></td><td><p class=\"NewStyle17\">True briefly when any VM enters the “stopping” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenAnyVmRebooting(void)</p></td><td><p class=\"NewStyle17\">True briefly when any VM enters the “rebooting” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenAnyVmRunning(void)</p></td><td><p class=\"NewStyle17\">True briefly when any VM enters the “running” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenAnyVmStopped(void)</p></td><td><p class=\"NewStyle17\">True briefly when any VM enters the “stopped” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenAnyVmPaused(void)</p></td><td><p class=\"NewStyle17\">True briefly when any VM enters the “paused” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmUuidCreating(string uuid)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified UUID enters the “creating” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmUuidStopping(string uuid)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified UUID enters the “stopping” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmUuidRebooting(string uuid)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified UUID enters the “rebooting” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmUuidRunning(string uuid)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified UUID enters the “running” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmUuidStopped(string uuid)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified UUID enters the “stopped” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmUuidPaused(string uuid)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified UUID enters the “paused” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmCreating(string name)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified name enters the “creating” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmStopping(string name)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified name enters the “stopping” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmRebooting(string name)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified name enters the “rebooting” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmRunning(string name)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified name enters the “running” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmStopped(string name)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified name enters the “stopped” state.</p></td></tr><tr><td><p class=\"NewStyle17\">whenVmPaused(string name)</p></td><td><p class=\"NewStyle17\">True briefly when the VM with the specified name enters the “paused” state.</p></td></tr></tbody></table><h1>Available actions</h1><table><tbody><tr><td><p class=\"NewStyle17\">sleepVm(string vm_name)</p></td><td><p class=\"NewStyle17\">Puts the named VM to sleep.</p></td></tr><tr><td><p class=\"NewStyle17\">resumeVm(string vm_name)</p></td><td><p class=\"NewStyle17\">Resumes the named VM from sleep.</p></td></tr><tr><td><p class=\"NewStyle17\">pauseVm(string vm_name)</p></td><td><p class=\"NewStyle17\">Pauses the named VM.</p></td></tr><tr><td><p class=\"NewStyle17\">unpauseVm(string vm_name)</p></td><td><p class=\"NewStyle17\">Unpauses the named VM.</p></td></tr><tr><td><p class=\"NewStyle17\">rebootVm(string vm_name)</p></td><td><p class=\"NewStyle17\">Reboots the named VM.</p></td></tr><tr><td><p class=\"NewStyle17\">shutdownVm(string vm_name)</p></td><td><p class=\"NewStyle17\">Shuts down the named VM.</p></td></tr><tr><td><p class=\"NewStyle17\">startVm(string vm_name)</p></td><td><p class=\"NewStyle17\">Starts the named VM.</p></td></tr><tr><td><p class=\"NewStyle17\">suspendVmToFile(string vm_name, string filename)</p></td><td><p class=\"NewStyle17\">Suspends the named VM to the specified file.</p></td></tr><tr><td><p class=\"NewStyle17\">resumeVmFromFile(string vm_name, string filename)</p></td><td><p class=\"NewStyle17\">Resumes the named VM from the specified file.</p></td></tr><tr><td><p class=\"NewStyle17\">sleepVmUuid(string vm_uuid)</p></td><td><p class=\"NewStyle17\">Puts the VM with the specified UUID to sleep.</p></td></tr><tr><td><p class=\"NewStyle17\">resumeVmUuid(string vm_uuid)</p></td><td><p class=\"NewStyle17\">Resumes the VM with the specified UUID from sleep.</p></td></tr><tr><td><p class=\"NewStyle17\">pauseVmUuid(string vm_uuid)</p></td><td><p class=\"NewStyle17\">Pauses the VM with the specified UUID.</p></td></tr><tr><td><p class=\"NewStyle17\">unpauseVmUuid(string vm_uuid)</p></td><td><p class=\"NewStyle17\">Unpauses the VM with the specified UUID.</p></td></tr><tr><td><p class=\"NewStyle17\">rebootVmUuid(string vm_uuid)</p></td><td><p class=\"NewStyle17\">Reboots the VM with the specified UUID.</p></td></tr><tr><td><p class=\"NewStyle17\">shutdownVmUuid(string vm_uuid)</p></td><td><p class=\"NewStyle17\">Shuts down the VM with the specified UUID.</p></td></tr><tr><td><p class=\"NewStyle17\">startVmUuid(string vm_uuid)</p></td><td><p class=\"NewStyle17\">Starts the VM with the specified UUID.</p></td></tr><tr><td><p class=\"NewStyle17\">suspendVmUuidToFile(string vm_uuid, string filename)</p></td><td><p class=\"NewStyle17\">Suspends the VM with the specified UUID to the specified file.</p></td></tr><tr><td><p class=\"NewStyle17\">resumeVmUuidFromFile(string vm_uuid, string filename)</p></td><td><p class=\"NewStyle17\">Resumes the VM with the specified UUID from the specified file.</p></td></tr><tr><td><p class=\"NewStyle17\">shutdownUnusedVpnvms(void)</p></td><td><p class=\"NewStyle17\">Shuts down all VPNVM-type VMs that are not required by any other VMs.</p></td></tr><tr><td><p class=\"NewStyle17\">shutdownDepsOfVm(string vm_name)</p></td><td><p class=\"NewStyle17\">Shuts down all dependencies of the named VM that are not required by any other VMs.</p></td></tr><tr><td><p class=\"NewStyle17\">shutdownDepsOfVmUuid(string vm_uuid)</p></td><td><p class=\"NewStyle17\">Shuts down all dependencies of the VM with the specified UUID that are not required by any other VMs.</p></td></tr><tr><td><p class=\"NewStyle17\">shutdownVpnvmsForVm(string vm_name)</p></td><td><p class=\"NewStyle17\">Shuts down all VPNVM-type dependencies of the named VM that are not required by any other VMs.</p></td></tr><tr><td><p class=\"NewStyle17\">shutdownVpnvmsForVmUuid(string vm_uuid)</p></td><td><p class=\"NewStyle17\">Shuts down all VPNVM-type dependencies of the VM with the specified UUID that are not required by any other VMs.</p></td></tr><tr><td><p class=\"NewStyle17\">doNothing(void)</p></td><td><p class=\"NewStyle17\">Does nothing.</p></td></tr><tr><td><p class=\"NewStyle17\">printString(string string_to_print)</p></td><td><p class=\"NewStyle17\">Prints a string to stdout; primarily for testing purposes.</p></td></tr><tr><td><p class=\"NewStyle17\">logString(string string_to_log)</p></td><td><p class=\"NewStyle17\">Prints a string to dom0’s system log.</p></td></tr><tr><td><p class=\"NewStyle17\">runScript(string path_to_script)</p></td><td><p class=\"NewStyle17\">Runs the script at the specified path.</p></td></tr><tr><td><p class=\"NewStyle17\">screenOn(void)</p></td><td><p class=\"NewStyle17\">Powers on the laptop display.</p></td></tr><tr><td><p class=\"NewStyle17\">screenOff(void)</p></td><td><p class=\"NewStyle17\">Powers off the laptop display.</p></td></tr><tr><td><p class=\"NewStyle17\">setBacklight(int backlight_percent)</p></td><td><p class=\"NewStyle17\">Sets the display backlight to the specified percentage.</p></td></tr><tr><td><p class=\"NewStyle17\">increaseBacklight(int percent_to_increase)</p></td><td><p class=\"NewStyle17\">Increases the backlight by the specified percentage.</p></td></tr><tr><td><p class=\"NewStyle17\">decreaseBacklight(int percent_to_decrease)</p></td><td><p class=\"NewStyle17\">Decrease the backlight by the specified percentage.</p></td></tr></tbody></table><h1>Backend Architecture</h1><h2>Policy Structure</h2><p>XCPMD’s policy system is composed of several core pieces:</p><ul><li><p>sources, or sensors, that react to the system state;</p></li><li><p>sinks, or actuators, that act upon the system; and</p></li><li><p>policy that determines how sources activate sinks.</p></li></ul><p>Sources and sinks are provided by dynamically loaded, self-contained modules that register the condition types and action types they provide with the core policy system. The module system is designed to allow easy extension of capabilities and the ability to load platform-dependent implementations of sources/sinks while providing a unified interface to the end user.</p><p>When all modules have been loaded, policy, in the form of rules and variables, can be configured. Rules determine which conditions will trigger which actions. A rule consists of a unique ID string, a set of conditions, a set of actions, and an optional set of undo actions. When all conditions are true, the rule becomes active, and its actions are executed in order. When any condition becomes untrue, the rule becomes inactive, and its undo actions (if any) are executed in order.</p><p>Conditions are instantiated from condition types, which are provided by source modules. Certain condition types may take arguments as defined by their prototype; arguments are provided to conditions at instantiation. Similarly, actions are instantiated from action types, which are provided by sink modules, and they may take arguments as well. All arguments are strictly typed. Type is inferred from argument format; details are available in the end-user documentation.</p><p>Variables are simply arguments whose value may change over the life of the program. Variables provide flexibility in configuration and can significantly improve rule readability, both in text form and in the DB. The usual argument type checking is enforced, and safeguards are in place against removing a variable that is currently in use.</p><h2>Program Flow</h2><p>The core of XCPMD is a humble libevent event loop, which handles various types of events (socket, DBus, timer, etc) in an orderly queue. The policy system builds on this structure by having its source modules either register their own events or hook into existing events. Once a relevant event occurs, the system determines what conditions rely on it. If any conditions have changed, the system finds the rules that own the changed conditions and evaluates all other conditions of those rules. If the changed condition causes a rule to change from inactive to active or vice versa, that rule’s actions (or undo actions) are then executed. When all rules with changed conditions have been evaluated, the program resumes waiting for events.</p><h1>Implementing New Modules</h1><p>This section provides a guide for developers interested in implementing new sources and sinks for XCPMD.</p><p>Modules are shipped as self-contained shared object (.so) files, and are loaded dynamically. It is strongly recommended that new modules use a constructor, as declared with the GCC function attribute __attribute__((constructor)), to perform initialization at load time; likewise, __attribute__((destructor)) should be used to perform cleanup at unload.</p><p>Source and sink modules are similar, but sources have a few additional tasks to perform and data to track in order to handle events in the way the policy system requires. </p><h2>Source Modules</h2><p>A source module should have a struct ev_wrapper for each input event that it handles. These structs are thin wrappers around input events that store information necessary for evaluating any condition_types depending on that event. Each ev_wrapper should have at least one condition_type depending on it, and each condition_type depends on one and only one ev_wrapper. At initialization, ev_wrappers should be registered using add_event() and condition_types should be registered with add_condition_type(). </p><p>When an input event occurs, the value member of that event’s ev_wrapper should be filled with the information needed by its condition_types, and handle_events() should be called with a reference to that ev_wrapper as its argument. It is strongly recommended that all of a module’s ev_wrappers be stored in a global array (herein called an event table) for consistency.</p><p>Every condition_type provided by a module must have a condition checking function with the following prototype: bool check(struct ev_wrapper *, struct arg_node *). Arguments are passed in as a linked list of struct arg_node; the prototype member must contain a space-separated list of characters describing the number and type of these arguments. Details on the exact format of these prototype strings are available in rules.h. Populating the pretty_prototype member with a C-like, human-readable prototype string is also recommended for self-documentation purposes. Within the condition checking function, arguments should be accessed using the get_arg() function.</p><h2>Sink Modules</h2><p>Sink modules, on the other hand, are a bit simpler. Each action_type provided must have an action function with the following prototype: void action(struct arg_node *). Like the arguments to condition checkers, action arguments are passed in as a linked list, whose prototype string must be in the prototype member. These action_types must be registered with add_action_type().</p><h2>Linking and Symbol Visibility</h2><p>XCPMD is linked with -rdynamic, which exposes all symbols loaded by the main program to all modules, including symbols from other modules. This greatly simplifies keeping universal data structures consistent across all modules, but has the unfortunate side effect of cluttering the namespace. For this reason, it is essential that all functions provided by modules are either static or uniquely named, including constructors and destructors. Otherwise, shadowing may occur, resulting in one module accidentally calling functions from another.</p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}