{
    "id": "confluence-155",
    "title": "xl Issues and Notes",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/27623453/xl+Issues+and+Notes",
    "content": "<p>Owned by Ross Philipson\nLast updated: Apr 01, 2016 by Ross Philipson\n\n</p><ac:structured-macro ac:macro-id=\"18801b2d-f552-44ca-b6e4-177e3858ba05\" ac:name=\"info\" ac:schema-version=\"1\"><ac:parameter ac:name=\"icon\">None</ac:parameter><ac:rich-text-body><p><ac:image ac:width=\"80\"><ri:attachment ri:filename=\"cc-by.png\"></ri:attachment></ac:image></p><p>Copyright 2015 by Assured Information Security, Inc. Created by Martin Osterloh &lt;osterlohm@<a href=\"http://ainfosec.com/\">ainfosec.com</a>&gt;. This work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy of this license, visit <a class=\"external-link\" href=\"http://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\">http://creativecommons.org/licenses/by/4.0/</a>.</p><p>Contributions by: Ross Philipson &lt;philipsonr@<a href=\"http://ainfosec.com\">ainfosec.com</a>&gt;</p></ac:rich-text-body></ac:structured-macro><h3>UIVM graphics</h3><p>We managed to get the UIVM up and running. We can sshv4v to it using 1.0.0.x. The UIVM has xenfb2 loaded but it does not create a /dev/fb0 node. The problem is the backed is not created but surfman. The dmbus RPC to create the node and hook up the front back connection is never called:</p><p>surfman/src/rpc.c:rpc_connect(type=DEVICE_TYPE_XENFB)</p><p>It looks like the call should come from the dm-agent running in dom0 (not sure what that is even doing there).</p><h3>Blktap dev passing to QEMU</h3><p>We have deliberately disabled QEMU support for directly supplying a VHD as a drive. The proper way in OpenXT is by using a blktap device (such as tapdisk2). Even though one can signal to LibXL to use a tap device in the config file, LibXL will always pass a vhd as an argument to QEMU. </p><p>Consider the configuration:</p><p>disk = [ \"tap2:tapdisk:<a href=\"http://vhd/storage/disks/debian-7.8-x64-clean.vhd,xvda,rw\">vhd:/storage/disks/debian-7.8-x64-clean.vhd,xvda,rw</a>\" ]</p><p>Unfortunately, XL will pass the following to QEMU:</p><p>libxl: debug: libxl_dm.c:1237:libxl__spawn_local_dm: -drive<br/>libxl: debug: libxl_dm.c:1237:libxl__spawn_local_dm: file=/storage/disks/debian-7.8-x64-clean.vhd,if=ide,index=0,media=disk,format=vpc,cache=writeback</p><p>This will likely need to be patched against XL.</p><h3>VIF naming in hotplug scripts</h3><p>When supplied a VIF in the config file via:</p><p>vif = [ \"bridge=xenbr0,script=vif-bridge\" ]</p><p>The supplied hotplug script (vif-bridge in /etc/xen/scripts/) is being called with vif$VIF_ID-emu instead of vif$VIF_ID where $VIF_ID starts at zero and increments every time and instance requests a VIF. Currently, the \"-emu\" part is being removed by sed. It is not 100% clear why the -emu is being appended.</p><h3>HVMLOADER not loading ROMS...no video</h3><p>The ROM loading was being skipped due to a missing xenstore value.</p><ac:structured-macro ac:macro-id=\"e7a5a90b-385f-4faa-bad1-1dbe4d9770cd\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">text</ac:parameter><ac:plain-text-body><![CDATA[        let local_stuff = [\n                \"serial/0/limit\",    string_of_int 65536;\n                \"console/limit\",     string_of_int 65536;\n                \"console/port\",      string_of_int console_port;\n                \"console/ring-ref\",  sprintf \"%nu\" console_mfn;\n                \"hvmloader/bios\",    \"seabios\";\n                \"hvmloader/seabios-legacy-load-roms\", \"1\";   <--- that guy\n        ] in\n \nLooks like this under /local/domain/<n>\n \nhvmloader = \"\"\n bios = \"seabios\"\n seabios-legacy-load-roms = \"1\"\n]]></ac:plain-text-body></ac:structured-macro><h3>VHD Compatibility</h3><p>Certain VHDs that were created with an upstream version of Xen cannot be used in current OpenXT. At least we think that is the case - really the only one is the CentOS VHD that was created at some point with some version of Xen tools. In general it is now believed that even though we change the VHD meta structures, our VHDs are still compatible. This is why:</p><ac:structured-macro ac:macro-id=\"4815c8b0-a031-49b4-bf47-8d4a14c49cb1\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">text</ac:parameter><ac:plain-text-body><![CDATA[struct dd_batmap_hdr {\n  char   cookie[8];       /* should contain \"tdbatmap\"                    */\n  u64    batmap_offset;   /* byte offset to batmap                        */  <--- This is the offset to where the allocation tables reside after this struct\n  u32    batmap_size;     /* batmap size in sectors                       */\n  u32    batmap_version;  /* version of batmap                            */\n  u32    checksum;        /* batmap checksum -- 1's complement of batmap  */\n  /* We add extra stuffs here like the keyhash but the batmap_offset is adjusted to skip them */\n};\n]]></ac:plain-text-body></ac:structured-macro><h3>Arguments to QEMU</h3><p>We did something non standard when invoking QEMU. We slapped the domid as arg 1. Just noting it here in case we run into trouble.</p><ac:structured-macro ac:macro-id=\"5a1f5a6c-cd4f-4f56-bd36-bb2089e30d95\" ac:name=\"code\" ac:schema-version=\"1\"><ac:plain-text-body><![CDATA[Nonstandard args:\nMar 17 19:11:34.942096 dm-agent-0: Info:spawn.c:spawn_dump_cmdline:352: Domain 3: Devmodel 0: cmdline: /usr/sbin/svirt-interpose 3 -xen-domid 3 -nodefaults -name qemu-3.0 -machine xenfv,max-ram-below-4g=0xf0000000 -m 1024 -smp 2 -boot cd -device xenmou -xen-acpi-pm -vga std -display surfman -serial pty -drive file=/storage/isos/null.iso,if=ide,index=2,media=cdrom,format=file,readonly=on -drive file=/dev/xen/blktap-2/tapdev5,if=ide,index=0,media=disk,format=raw,readonly=off -drive file=atapi-pt-local:/dev/bsg/2:0:0:0,media=cdrom,if=atapi-pt,format=raw,readonly=off -soundhw ac97\n \nNonstandard hackery in the wrapper:\nDOMID=$1\nshift 1]]></ac:plain-text-body></ac:structured-macro><p> </p><h3>GDB and QEMU</h3><p>Running QEMU in GDB has proven to be very helpful. Simply copy the gdb binaries (gdb, gdbserver, and gdbtui) on to your OpenXT machine and replace the /usr/lib/xen/bin/qemu-system-i386 script with:</p><p>#!/bin/bash</p><p>DOMID=`cat /tmp/domid`<br/>let \"NEWID=$DOMID+1\"<br/>echo \"$NEWID\" &gt; /tmp/domid</p><p>exec gdbserver 0.0.0.0:1234 /usr/bin/qemu-system-i386 -gdb stdio -xen-domid $DOMID -nodefaults -name qemu-3.0 -machine xenfv,max-ram-below-4g=0xf0000000 -m 1024 -drive file=/dev/xen/blktap-2/tapdev0,if=ide,index=0,media=disk,format=raw,readonly=off #-vnc 192.168.2.2:5900 $@</p><p>In another window, you can run gdb and do target remote localhost:1234.</p><p>TODO: QEMU mess and sv-interposer and qemu-dm-wrapper ... what is REALLY necessary?</p><h3>VNC support in QEMU</h3><p>In order for us to see what is happening inside the guest, we have to enable VNC. Per default, out QEMU does not enable VNC connections. The recipe for it, however, makes that easy to change. Instead of --disable-vnc, we write --enable-vnc. Now, QEMU has several new dependencies. </p><ul><li>libpng (already being built and pulled into dom0)</li><li>libgnutls (not being pulled into dom0)</li><li>libtasn1 (not being pulled into dom0)<br/> </li></ul><p>The quick and dirty way is to copy the image directory onto your OpenXT machine and add the libraries manually.</p><h3><strong>Notes on blktap2 and tapdisk</strong> </h3><div><div class=\"syntaxhighlighter sh-confluence nogutter text\"><p> </p><table><tbody><tr><td><div class=\"container\" title=\"Hint: double-click to select code\"><div class=\"line number1 index0 alt2\"><code class=\"text plain\"># Some notes on how how tapdevs and associated devices are created. It begins here:</code></div><div class=\"line number2 index1 alt1\"> </div><div class=\"line number3 index2 alt2\"><code class=\"text plain\">libxl:libxl__blktap_devpath calls <a href=\"http://libblktapctl.so\">libblktapctl.so</a>:tap_ctl_create directly.</code></div><div class=\"line number4 index3 alt1\"><code class=\"text plain\">xenops/<a href=\"http://device.ml\">device.ml</a>:mount calls it indirectly by invoking tap-ctl with the create option (which calls tap-ctl:tap_cli_create)</code></div><div class=\"line number5 index4 alt2\"><code class=\"text spaces\"> </code> </div><div class=\"line number6 index5 alt1\"><code class=\"text plain\"># This function in <a href=\"http://libblktapctl.so\">libblktapctl.so</a> does 4 important things that are listed below</code></div><div class=\"line number7 index6 alt2\"><code class=\"text plain\">tap_cli_create:</code></div><div class=\"line number8 index7 alt1\"><code class=\"text spaces\">  </code><code class=\"text plain\">tap_ctl_allocate</code></div><div class=\"line number9 index8 alt2\"><code class=\"text spaces\">  </code><code class=\"text plain\">tap_ctl_spawn</code></div><div class=\"line number10 index9 alt1\"><code class=\"text spaces\">  </code><code class=\"text plain\">tap_ctl_attach</code></div><div class=\"line number11 index10 alt2\"><code class=\"text spaces\">  </code><code class=\"text plain\">tap_ctl_open</code></div><div class=\"line number12 index11 alt1\"><code class=\"text spaces\"> </code> </div><div class=\"line number13 index12 alt2\"><code class=\"text plain\">tap_ctl_allocate:</code></div><div class=\"line number14 index13 alt1\"><code class=\"text spaces\">  </code><code class=\"text plain\"># Open the blktap driver</code></div><div class=\"line number15 index14 alt2\"><code class=\"text spaces\">  </code><code class=\"text plain\"># Allocate a ring device and an IO device using the BLKTAP2_IOCTL_ALLOC_TAP ioctl (see below).</code></div><div class=\"line number16 index15 alt1\"><code class=\"text spaces\">  </code><code class=\"text plain\"># tap_ctl_make_device then makes the ring device node /dev/xen/blktap-2/blktapX and an IO device node /devxen/blktap-2/tapdevX</code></div><div class=\"line number17 index16 alt2\"><code class=\"text spaces\"> </code> </div><div class=\"line number18 index17 alt1\"><code class=\"text plain\">tap_ctl_spawn:</code></div><div class=\"line number19 index18 alt2\"><code class=\"text spaces\">  </code><code class=\"text plain\"># Start a new tapdisk2 process that will be associated with the X tap devices.</code></div><div class=\"line number20 index19 alt1\"><code class=\"text spaces\">  </code><code class=\"text plain\"># tapdisk2 creates the listener socket for the new process.</code></div><div class=\"line number21 index20 alt2\"><code class=\"text spaces\">  </code><code class=\"text plain\"># tapdisk2 registers the tapdisk_control_handle_request</code></div><div class=\"line number22 index21 alt1\"><code class=\"text spaces\"> </code> </div><div class=\"line number23 index22 alt2\"><code class=\"text plain\">tap_ctl_attach:</code></div><div class=\"line number24 index23 alt1\"><code class=\"text spaces\">  </code><code class=\"text plain\"># Attach to the listening tapdisk2 process just started so now messages can be passed between <a href=\"http://libblktapctl.so\">libblktapctl.so</a> and that process.</code></div><div class=\"line number25 index24 alt2\"><code class=\"text spaces\"> </code> </div><div class=\"line number26 index25 alt1\"><code class=\"text plain\">tap_ctl_open:</code></div><div class=\"line number27 index26 alt2\"><code class=\"text spaces\">  </code><code class=\"text plain\"># Send the TAPDISK_MESSAGE_OPEN to the new tapdisk2 process.</code></div><div class=\"line number28 index27 alt1\"><code class=\"text spaces\"> </code> </div><div class=\"line number29 index28 alt2\"><code class=\"text plain\"># In the new tapdisk2 process associated with the X devices allocated above.</code></div><div class=\"line number30 index29 alt1\"><code class=\"text plain\">tapdisk_control_handle_request:</code></div><div class=\"line number31 index30 alt2\"><code class=\"text spaces\">  </code><code class=\"text plain\"># Get message TAPDISK_MESSAGE_OPEN and call:</code></div><div class=\"line number32 index31 alt1\"><code class=\"text spaces\">  </code><code class=\"text plain\">tapdisk_control_open_image:</code></div><div class=\"line number33 index32 alt2\"><code class=\"text spaces\">    </code><code class=\"text plain\"># Send the BLKTAP2_IOCTL_CREATE_DEVICE ioctl to blkdev (see below).</code></div><div class=\"line number34 index33 alt1\"><code class=\"text plain\"># Down in the blktap driver, the above activity translates to:</code></div><div class=\"line number35 index34 alt2\"><code class=\"text plain\">blktap_control_ioctl:</code></div><div class=\"line number36 index35 alt1\"><code class=\"text spaces\">  </code><code class=\"text plain\"># BLKTAP2_IOCTL_ALLOC_TAP maps to BLKTAP_IOCTL_ALLOC_TAP</code></div><div class=\"line number37 index36 alt2\"><code class=\"text spaces\">  </code><code class=\"text plain\"># Call blktap_control_create_tap to create the tap ring and IO devices.</code></div><div class=\"line number38 index37 alt1\"><code class=\"text spaces\"> </code> </div><div class=\"line number39 index38 alt2\"><code class=\"text plain\">blktap_ring_ioctl:</code></div><div class=\"line number40 index39 alt1\"><code class=\"text spaces\">  </code><code class=\"text plain\"># BLKTAP2_IOCTL_CREATE_DEVICE maps to BLKTAP_IOCTL_CREATE_DEVICE_COMPAT. Calls:</code></div><div class=\"line number41 index40 alt2\"><code class=\"text spaces\">  </code><code class=\"text plain\">blktap_device_create:</code></div><div class=\"line number42 index41 alt1\"><code class=\"text spaces\">    </code><code class=\"text plain\"># Sets up the /dev/tdx node name (note little x corresponds to a, b, c...)</code></div><div class=\"line number43 index42 alt2\"><code class=\"text spaces\">    </code><code class=\"text plain\"># Creates and adds the actual block device with add_disk() (see include/linux/genhd.h for generic block disk devices).</code></div><div class=\"line number44 index43 alt1\"><code class=\"text spaces\">    </code><code class=\"text plain\"># The rest happens in the standard udev way.</code></div><div class=\"line number45 index44 alt2\"><code class=\"text spaces\"> </code> </div><div class=\"line number46 index45 alt1\"> </div><div class=\"line number47 index46 alt2\"><code class=\"text plain\">NOTE: when destroying a tapdev with tap-ctl the process id is the tapdisk2 process that own the tap devs. The minor number is what is called X above.</code></div><div><code class=\"text plain\"><br/></code></div></div></td></tr></tbody></table></div></div>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}