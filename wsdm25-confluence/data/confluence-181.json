{
    "id": "confluence-181",
    "title": "SuperHID",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/14843998/SuperHID",
    "content": "<p>Owned by Ross Philipson\nLast updated: Nov 06, 2015 by Ross Philipson\n\n</p><ac:structured-macro ac:macro-id=\"401e281c-2be8-4de4-b88e-33aa8260f4e1\" ac:name=\"info\" ac:schema-version=\"1\"><ac:parameter ac:name=\"icon\">None</ac:parameter><ac:rich-text-body><p><ac:image ac:width=\"80\"><ri:attachment ri:filename=\"cc-by.png\"><ri:page ri:content-title=\"Documentation Guidelines\" ri:space-key=\"OD\"></ri:page></ri:attachment></ac:image></p><p>Copyright 2015 by Assured Information Security, Inc. Created by Jean-Edouard Lejosne &lt;lejosnej@ainfosec.com&gt;. This work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy of this license, visit <a class=\"external-link\" href=\"http://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\">http://creativecommons.org/licenses/by/4.0/</a>.</p></ac:rich-text-body></ac:structured-macro><p><ac:structured-macro ac:macro-id=\"6c269aa2-4585-4a58-9c86-850305358e79\" ac:name=\"toc\" ac:schema-version=\"1\"></ac:structured-macro></p><h1>SuperHID v2</h1><h2>Downsides of SuperHID v1</h2><p>SuperHID v1 extends the Linux HID gadget with multitouch stuff.<br/>Using the gadget subsystem, originally designed for real hardware, implies having to simulate and drive a ton of hardware:</p><ul><li>A USB host controller (HCD)</li><li>A USB device controller (UCD), along with its endpoints and the glue to the HCD</li><li>A USB device that \"plugs\" to a UCD</li></ul><p>The resulting fake device is then passed to a guest using the PV USB backend/frontend.</p><p>In the proof-of-concept, the dummy_hcd kernel module is used as an HCD+UCD, with the critical limitation that it supports only 1 USB device, with no easy way to extend to multiple devices.</p><p>In general, the gadget subsystem is not meant to be used like that. Gadgets are for \"slave\" USB devices, not hosts...</p><h2>New ideas</h2><p>In the current scheme, we spend a lot of effort and resource to simulate a \"real\" device, when in the end it gets \"virtualized\"...</p><p>The main idea for making it simpler would be to stop using the gadget subsystem, and just plug SuperHID somewhere in the PV USB mechanism. The frontends just bring up \"fake\" devices anyway!</p><p>I see two ways of doing this:</p><ul><li>usbback could be modified to be able to use a special kernel module in place of real USB devices. That way, the frontends would need no modification, but that implies understanding and modifying the huge mess that is usbback...</li><li>A separate USB backend could be written, using some of the guts of usbback as a starting point. That new backend would talk to SuperHID instead of real devices. That means not having to mess with usbback, but the frontends may have to be modified to be able to deal with multiple PV USB backends...</li></ul><p>The second approach seems to make the most sense to me, so that's what I'm looking at.</p><p>Here's a picture that compares the two designs:</p><p><ac:image ac:width=\"600\"><ri:attachment ri:filename=\"SuperHID_Diagram.png\"></ri:attachment></ac:image></p><h1>SuperHID v1</h1><h2>Introduction</h2><p>Some HID background could be useful to understand the core of SuperHID.</p><p>When using SuperHID, the input follows that path:</p><pre><code>Device (HID)\n  v\nLinux (HID-&gt;Event)\n  v\ninput_server (Event)\n  v\nSuperHID plugin (Event-&gt;HID)\n  v\nSuperHID driver (HID)\n  v\nSuperHID fake device (HID-&gt;USB)\n</code></pre><p>Then, passing the superhid fake device through to any guest gives it all the input we want.</p><h2>Highlights</h2><ul><li>No code needed in the guest VM</li><li>Multi-touch works in Microsoft Windows 8, and any other pv-usb-enabled guest</li><li>All the input still goes through input_server, which gives total control over what event goes to which VM</li></ul><h2>Downsides</h2><ul><li>The input events follow a long path, as illustrated above</li></ul><h2>To do</h2><ul><li>Implement the plugin directly in input_server, to reduce the packets journey.</li><li>Implement a way to skip the relative-to-absolute translation that happens in input_server, to make input faster and more reliable (but potentially breaking other input features).</li><li>Enhance the superhid gadget driver (and/or the virtual USB controller) to be able to create multiple devices (right now we get only one).</li><li>Get the toolstack and the USB subsystem to automatically pass the right SuperHID fake input device to the right guest.</li></ul><h2>The USB controller</h2><p>The superhid proof-of-concept is now functionnal, and the superhid device itself can be used as-is.</p><p>However, the USB controller needs a lot of work. Right now, we use dummy_hcd, which simulates a real life controller, with power, latency and ports limitations. This module has been created only for development purposes, to simulate devices before actually getting access to the real hardware. The problem of that module is that is requires the clock to be set to 1000HZ, and it probably uses too much resources.</p><p>What SuperHID needs is something that would be more of a \"fake USB controller\", that would be dummy-er than dummy_hcd. Like just enough code to create a fake controller and pipe the packets to the fake devices (gadgets).</p><h2>How to build and use SuperHID</h2><ul><li>Make sure the dom0 Linux kernel has been (re)compiled with an HZ value of 1000 and gadget support.</li><li>In OE: ./bb xenclient-superhid</li><li>Send and install the resulting module to the (OpenXT) test machine (superhid.ko)</li><li>In input.git/superhid (with a 32 bits compiler): gcc -o shp -lpthread -levent superhidplugin.c</li><li>Send shp to the test machine</li><li><p>On the test machine:</p><pre><code># cat &gt; /etc/modprobe.d/superhid.conf &lt;&lt;EOF\noptions superhid idVendor=0x03eb idProduct=0x211c bcdDevice=0x0001 iManufacturer=jed iProduct=superhid\nEOF\n# modprobe dummy_hcd\n# modprobe superhid\n# ./shp &lt;domid&gt;\n</code></pre></li></ul><p>Note: idVendor and idProduct are set to an existing input device to make some guests recognise it. Ideally, those values could be anything, as the device is just a standard HID device.</p><ul><li>Pass the superhid device to the (Windows/Linux) guest</li></ul><p>At that point, the guest should see a new multitouch HID device and should be able to use it.</p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassianâ€™s official documentation for the most current information.",
    "space": "DC"
}