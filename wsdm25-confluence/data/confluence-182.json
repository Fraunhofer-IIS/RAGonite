{
    "id": "confluence-182",
    "title": "XENMOU2 Specification",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/15892485/XENMOU2+Specification",
    "content": "<p>Owned by Ross Philipson\nLast updated: Oct 14, 2015 by Ross Philipson\n\n</p><p>This page describes the second version of the XenMou protocol. While the first version supported an absolute mouse pointer, this second version is designed to be more flexible, and support a variety of different types of input device, including a mulitouch tablet screen.</p><p>As before, XenMou is a PCI device which may be present at any BDF in the system. The Xen PCI Vendor ID 5853 and Device ID C110 will be assigned for this device. It will be an Input Device Class, Mouse Subclass (0x0902).</p><p>The device can generate an interrupt.</p><p>This PCI device contains 1 BAR: BAR0 is non prefetchable memory of 8k+ bytes (3+ pages) containing MMIO registers and mouse event data.</p><p>The pages in BAR0 contain a page for Global registers, one or more pages for event data, and a final page containing a device configuration space. These three sections are described in the three sections below.</p><p><ac:structured-macro ac:macro-id=\"f696237a-3b06-42b5-a8ab-84441ecc10bd\" ac:name=\"toc\" ac:schema-version=\"1\"></ac:structured-macro></p><h2><span class=\"mw-headline\">Global Registers (Range 0x00000 - 0x00FFF)</span></h2><p>The global registers control features of the xenmou adapter that reflect the entire device.</p><h4><span class=\"mw-headline\">0x00000 - XMOU_MAGIC</span></h4><p><em><strong>Type:</strong> Read-Only</em></p><p>Magic number. This register always reads <strong>0x584D4F55</strong></p><h4><span class=\"mw-headline\">0x00004 - XMOU_REV</span></h4><p><em><strong>Type:</strong> Read-Only</em></p><p>Revision number of the back end. This register reads 0x1 until XMOU_CLIENT_REV has been written too, after which it returns it true version (0x2 as of writing). This value should not be used as an indicator of compatibility, as newer versions may be backwards compatible. Please refer to XMOU_CLIENT_REV for use in version compatibility checking.</p><h4><span class=\"mw-headline\">0x00100 - XMOU_CONTROL</span></h4><p><em><strong>Type:</strong> Read-Write</em></p><p>Control register to change backend settings.</p><pre> Bit 0:  XMOU_EN Set to enable the xenmou device.\n Bit 1:  INT_EN  Global bit to enable interrupts from the device.\n Bit 2:  MOU_V2  This is no longer supported.  It use to enable version 2 of the xenmou protocol.  XMOU_CLIENT_REV should be used instead.\n Bits 3 - 31: Unused.</pre><h4><span class=\"mw-headline\">0x00104 - XMOU_EVENT_SIZE</span></h4><p><em><strong>Type:</strong> Read-Only</em></p><p>Size in bytes of the individual event data structures in the event register range.</p><h4><span class=\"mw-headline\">0x00108 - XMOU_EVENT_NPAGES</span></h4><p><em><strong>Type:</strong> Read-Only</em></p><p>Number of pages that make up the the event register range.</p><h4><span class=\"mw-headline\">0x0010C - XMOU_ACCELERATION:</span></h4><p><em><strong>Type:</strong> Write-Only</em></p><p>Not used.</p><h4><span class=\"mw-headline\">0x000110 - XMOU_ISR:</span></h4><p><em><strong>Type:</strong> Read-Only</em></p><p>Interrupt status register. Write to dismiss interrupt.</p><pre> Bit 0:   INT  Indicates if this device is currently generating an interrupt.\n Bits 1 - 31: Unused.</pre><h4><span class=\"mw-headline\">0x00114 - XMOU_CONF_SIZE</span></h4><p><em><strong>Type:</strong> Read-Only</em></p><p>This returns the size, in bytes of the XenMou device configuration record (described later under <a href=\"http://smo/xcwiki/index.php/XENMOU2_Hardware_Specification#Device_configuration_space\" title=\"\">#Device_configuration_space</a>). This value should be used when indexing the array of these records, in place of the size you expect the record to be. This is to allow for expansion, and failing to do so may result in compatibility issues.</p><h4><span class=\"mw-headline\">0x00118 - XMOU_CLIENT_REV</span></h4><p><em><strong>Type:</strong> Read-Write</em></p><p>This should be set on start up, to the version of XenMou spec you expect to use. If not set, the xenmou back end will follow the <a href=\"http://smo/xcwiki/index.php/XENMOU_Hardware_Specification\" title=\"XENMOU Hardware Specification\">xenmou version 1 spec</a>. Once you have written the spec version number (0x2 as of writing), you should read this register back. If the value read is not that which was written, then this indicates a fail condition. Reading 0 indicates that the version was rejected, a newer version of the spec may need to be adhered to. Note that newer versions of the back end may still support older versions of the spec - but not necessarily all versions. This register may only be written to before XMOU_EN of the control register, has been enabled. Attempts to change the protocol version, while enabled, will be ignored.</p><h2><span class=\"mw-headline\">Event Registers (Range 0x01000 - 0x0nFFF)</span></h2><p>The event registers occupy XMOU_EVENT_NPAGES pages of 4096 bytes. There are (PAGE_SIZE/XMOU_EVENT_SIZE - 1) individual event data structures per page. The individual event data structures are each XMOU_EVENT_SIZE bits in size (XMOU_EVENT_SIZE is always 64 or greater bits). The first event data structure on the first page is unique in that it holds the read and write pointer indexing into the other event data structures.</p><h3><span class=\"mw-headline\">0x01000 : XMOU_READ_PTR:</span></h3><p><em><strong>Type:</strong> Read-Write</em></p><p>Current read offset index to the next event data structures to read (in XMOU_EVENT_SIZE units).</p><h3><span class=\"mw-headline\">0x01004 : XMOU_WRITE_PTR:</span></h3><p><em><strong>Type:</strong> Read-Only</em></p><p>Current write offset index to the event data structures one beyond the last one written to (in XMOU_EVENT_SIZE units).</p><h3><span class=\"mw-headline\">0x01000 + (XMOU_EVENT_SIZE) : Event Record Queue</span></h3><p><em><strong>Type:</strong> Read-Only</em></p><p><br/>The event registers data structures starting at (0x01000 + XMOU_EVENT_SIZE) form a logical ring spanning XMOU_EVENT_NPAGES pages. The offset pointers above are indices into the ring. If the write pointer is less than the read pointer then the ring has wrapped. When the read pointer is not equal to the write pointer, there are events to read. The pointers being equal always means there are no events to read, that is read == write never means that the ring is full with (PAGE_SIZE/XMOU_EVENT_SIZE - 1) events. A full ring will have a maximum of (PAGE_SIZE/XMOU_EVENT_SIZE - 2) events in it. The ring may wrap at this point, controlled by the underlying virtual HW. When events have been consumed, the xenmou driver software moves the read pointer forward up to the write pointer. Driver software never moves the write pointer. A interrupt is generated when events need the read from the buffer - this is when a SYN_REPORT event (described later) is added. The event record format is described in the next section.</p><h3><span class=\"mw-headline\">Event Records</span></h3><p>Each of the event records are formatted in the following manner:</p><ac:structured-macro ac:macro-id=\"391b3613-38fd-4a18-ab12-548462997086\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">cpp</ac:parameter><ac:plain-text-body><![CDATA[uint16 type  // Type of record, including KEY (key/button), REL (relative scalar), ABS (absolute scalar), SYN (Synchronization events.) or DEV (Device change events).\nuint16 code  // This indicated which item (be it a key or axis) this record represents.\nuint32 value // This is the new value for the item indicated by two field above. For a button or key, this would be a Boolean.]]></ac:plain-text-body></ac:structured-macro><p>The records above are able to accommodate a huge number of different types of event. Furthermore, events are aggregated to form more complex events. Each input device will only be able to send a small subset of the possible events. DEV (device) events are used to indicate which device is emitting the following events, as well as indicating which events are possible. For example a tablet stylus can emit absolute X and Y events, while a traditional mouse emits relative X and Y events.</p><p>Below is a small subset of events that are possible. This list should probably be considered the minimum to set to implement. A fuller list can be found <a class=\"external text\" href=\"http://lxr.free-electrons.com/source/include/linux/input.h\" rel=\"nofollow\" title=\"http://lxr.free-electrons.com/source/include/linux/input.h\">here</a> with descriptions <a class=\"external text\" href=\"http://www.kernel.org/doc/Documentation/input/event-codes.txt\" rel=\"nofollow\" title=\"http://www.kernel.org/doc/Documentation/input/event-codes.txt\">here</a>. Detail on the multitouch protocol <a class=\"external text\" href=\"http://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt\" rel=\"nofollow\" title=\"http://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt\">here</a>.</p><h4><span class=\"mw-headline\">Type 0x6 DEV: Device</span></h4><p>These events describe actions relating to the device emmiting the remaining events. DEV events are not subject to Synchronization events.</p><table><tbody><tr><th>Code</th><th>Name</th><th>Description</th></tr><tr><td>0x1</td><td>DEV_SET</td><td>Events after this event belong to the device indicated by &lt;value&gt;. A value of -1 indicates that it is from an unknown source. This number may be referred to as the device's slot number.</td></tr><tr><td>0x2</td><td>DEV_CONF</td><td>This indicates that a new device has been created, which from here shall be referred to as &lt;value&gt;. The provided slot number ( &lt;value&gt; ) can be used to find a description of this device, in the configuration space, described later. This information is expected to be considered before attempting to decode events for this device.</td></tr><tr><td>0x3</td><td>DEV_RESET</td><td>This indicates that device &lt;value&gt; is no longer valid, and any resources associated with this may be freed. If &lt;value&gt; is 0xFFFF, then all devices are existing invalid - such event is used on start up.</td></tr></tbody></table><h4><span class=\"mw-headline\">Type 0x0 SYN: Synchronization</span></h4><table><tbody><tr><th>Code</th><th>Name</th><th>Description</th></tr><tr><td>0x0</td><td>SYN_REPORT</td><td>This is used as a barrier to indicate that all events of other types (excluding DEV), which occur between the same set of SYN:REPORT events, occurred at the same time. That is to say, events between pairs of SYN:REPORT events are to be aggregated. For example, when moving a mouse, it is common for both the X and Y coordinate to change together, and so an event for each would be emitted, and because they where emmited between a pair of SYN:REPORT events, they would be aggregated. If however, only one axis changed, then only an event for that axis would be emitted. After this event has been added to the buffer, and interrupt is generated.</td></tr><tr><td>0x2</td><td>SYN_MT_REPORT</td><td>This is used for less able multitouch devices, to separate multiple sets of X/Y coordinates. We currently have no devices which do this.</td></tr><tr><td>0x3</td><td>SYN_DROPPED</td><td>This informs the client when input events have been dropped from the evdev input buffer due to a buffer overrun.<p>The client should use this event as a hint to reset its state or ignore all following events until the next packet begins. Client should ignore all events up to and including next SYN_REPORT.</p></td></tr></tbody></table><h4><span class=\"mw-headline\">Type 0x2 REL: Relative</span></h4><table><tbody><tr><th>Code</th><th>Name</th><th>Description</th></tr><tr><td>0x00</td><td>REL_X</td><td>Movement on the X axis.</td></tr><tr><td>0x01</td><td>REL_Y</td><td>Movement on the Y axis.</td></tr><tr><td>0x08</td><td>REL_WHEEL</td><td>Vertical wheel movement.</td></tr></tbody></table><h4><span class=\"mw-headline\">Type 0x3 ABS: Absolute</span></h4><table><tbody><tr><th>Code</th><th>Name</th><th>Description</th></tr><tr><td>0x00</td><td>ABS_X</td><td>Position on the X axis.</td></tr><tr><td>0x01</td><td>ABS_Y</td><td>Position on the Y axis.</td></tr><tr><td>0x18</td><td>ABS_PRESSURE</td><td>The pressure the pen/tool is being applied.</td></tr><tr><td>0x2f</td><td>ABS_MT_SLOT</td><td>Each finger/pen in contact with the screen is given a slot number, and this is maintained until it is released. Multitouch events, on the current device, are henceforth for this slot. If only one finger/pen is in contact with the screen, then only one slot in required, and so this event may be omitted. If multiple fingers/pens are in contact with the screen, it would be common for may slot changes to occur during one pair SYN:REPORT events, to indicate each finger moved at the same time.</td></tr><tr><td>0x35</td><td>ABS_MT_POSITION_X</td><td>X coordinate for the current slot. (Finger/pen)</td></tr><tr><td>0x36</td><td>ABS_MT_POSITION_Y</td><td>Y coordinate for the current slot. (Finger/pen)</td></tr><tr><td>0x39</td><td>ABS_MT_TRACKING_ID</td><td>Unique ID of initiated contact, a value of -1 indicates finger/pen released.</td></tr></tbody></table><h4><span class=\"mw-headline\">Type 0x01 KEY: Key/Button</span></h4><table><tbody><tr><th>Code</th><th>Name</th><th>Description</th></tr><tr><td>0x110</td><td>BTN_LEFT</td><td>The left button on a mouse.</td></tr><tr><td>0x111</td><td>BTN_RIGHT</td><td>The right button on a mouse.</td></tr><tr><td>0x112</td><td>BTN_MIDDLE</td><td>The middle button on a mouse.</td></tr><tr><td>0x113</td><td>BTN_SIDE</td><td>The side button on a mouse.</td></tr><tr><td>0x114</td><td>BTN_EXTRA</td><td>The extra button on a mouse.</td></tr><tr><td>0x115</td><td>BTN_FORWARD</td><td>The forward button on a mouse.</td></tr><tr><td>0x116</td><td>BTN_BACK</td><td>The back button on a mouse.</td></tr><tr><td>0x117</td><td>BTN_TASK</td><td>The task button on a mouse.</td></tr><tr><td>0x140</td><td>BTN_TOOL_PEN</td><td>The current tool is now a pen.</td></tr><tr><td>0x141</td><td>BTN_TOOL_RUBBER</td><td>The current tool is now a rubber.</td></tr><tr><td>0x145</td><td>BTN_TOOL_FINGER</td><td>The current tool is now a finger.</td></tr><tr><td>0x146</td><td>BTN_TOOL_MOUSE</td><td>The current tool is now a mouse.</td></tr><tr><td>0x14a</td><td>BTN_TOUCH</td><td>The current tool touched the surface.</td></tr><tr><td>0x14b</td><td>BTN_STYLUS</td><td>The first button on the stylus was pressed.</td></tr><tr><td>0x14c</td><td>BTN_STYLUS2</td><td>The second button on the stylus was pressed.</td></tr></tbody></table><h3><span class=\"mw-headline\">Example</span></h3><p>A stream might look as follows:</p><ac:structured-macro ac:macro-id=\"3fbf780c-2700-4d14-b71b-a726fb0a2ca5\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">cpp</ac:parameter><ac:plain-text-body><![CDATA[DEV_RESET 0xFFFF\nDEV_CONF 4              /* The config associated indicates its a stylus */\nDEV_CONF 7              /* The config associated indicates its an multi-touch device */\nDEV_SET 4\n\nABS_X 345\nABS_Y 987\nBTN_TOOL_PEN 1         /* Pen is hovering over the surface*/\nSYN_REPORT\n\nABS_X 346\nSYN_REPORT\n\nABS_Y 986\nSNY_REPORT\n\nABS_X 344\nABS_Y 985\nABS_PRUSSURE 45\nBTN_TOUCH 1          /* Pen touches the surface */\nSYN_REPORT\n\nABS_PRESSURE 48\nSYN_REPORT\n\nABS_X 300\nABS_PRESSURE 20\nSYN_REPORT\n\nBTN_TOUCH 0          /* Pen is no longer touching surface */\nABS_X 388\nSYN_REPORT\n\nABS_Y 810\nABS_X 320\nBTN_TOOL_PEN 0      /* Pen is no longer hovering over the surface */\nSYN_REPORT\n\nDEV_SET 7\n\n\nABS_MT_SLOT 0                  /* First finger goes down */\nABS_MT_TRACKING_ID 45\nABS_MT_POSITION_X 200\nABS_MT_POSITION_Y 300\nSYN_REPORT\n\nABS_MT_POSITION_X 210          /* Still slot 0 */\nSYN_REPORT\n\nABS_MT_POSITION_X 220\nABS_MT_POSITION_Y 302\nSYN_REPORT\n\nABS_MT_POSITION_X 225\nABS_MT SLOT 1                  /* Second finger goes down */\nABS_MT_TRACKING_ID 46\nABS_MT_POSITION_X 700\nABS_MT_POSITION_Y 800\nSYN_REPORT\n\nABS_MT_SLOT 0\nABS_MT_POSITION_X 226\nABS_MT_POSITION_Y 308\nABS_MT_SLOT 1\nABS_MT_POSITION_Y 810\nSYN_REPORT\n\nABS_MT_POSITION_Y 815          /* Still on slot 1! */\nABS_MT_POSITION_X 720\nSYN_REPORT\n\nABS_MT_SLOT 0                  /* first finger lifted */\nABS_MT_TRACKING_ID -1\nABS_MT_SLOT 1\nABS_MT_POSITION_X 725\nSYN_REPORT\n\nABS_MT_POSITION_Y 816          /* Still on slot 1! */\nABS_MT_POSITION_X 740\nSYN_REPORT\n\nABS_MT_TRACKING_ID -1          /* Second finger is lifted */\nABS_MT_POSITION_X 741\nSYN_REPORT]]></ac:plain-text-body></ac:structured-macro><h2><span class=\"mw-headline\">Device configuration space</span></h2><p>After receiving a DEV_CONF event, the details of the new device can be found in this space. The configuration space consists of an array of records in the format described below. The stride of the array should be taken as XMOU_CONF_SIZE, and not a calculation of the size of the device record. Although this may be programmatically inconvenient, it allows for record expansion, without breaking compatibility.</p><p>The index into this table is the device's slot number. Not all slots are necessarily filled. Entries into this array may be added or removed in real time, as devices are added or removed to the system. The DEV events are used to indicate when the array has been updated.</p><p>This array is located on the page immediately following the event record pages. That is the say it is located at the base address + n * 0x1000, where n = 1 + number of event pages.</p><h3><span class=\"mw-headline\">Device Record</span></h3><ac:structured-macro ac:macro-id=\"caf2c811-8871-4537-8fac-19a80696f758\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">cpp</ac:parameter><ac:plain-text-body><![CDATA[ char name[40]      // This is the name of the device, in text.\n  \n uint32 evbits      // A bit mask indicating which types are used.  Eg, 0xB would indicate SYN events, KEY and ABS events, \n                    // but not REL events (Or any other type).  DEV events are alawys present, and not included in this bit mask.\n  \n uint32 absbits[2]  // A bit mask (64 bits) indicating which absolute codes are used.  Each bit corresponds to the code number, \n                    // so 0x3 would indicate ABS_X codes and ABS_Y codes.\n  \n uint32 relbits     // A bit mask indicating which relative codes are used. (At present, this is never used)\n  \n uint32 btnbits[3]  // A bit mask (96 bits) indicating which button codes are in use.  This bit mask starts at code 0x100, and not 0x0 as for the other bit mask. \n                    // A bit mask of 0xC00 would indicate the device is capable of emitting BTN_LEFT and BTN_RIGHT events]]></ac:plain-text-body></ac:structured-macro><h3><span class=\"mw-headline\">Examples</span></h3><p>If a device support ABS_MT_POSITION_X, then that code is ordinal 0x35.</p><p>The bitmask that repressents this is 1 &lt;&lt; 0x35 = 0x20000000000000</p><p><br/>If it support BTN_FORWARD, then that ordinal code is 0x115.</p><p>The bitmask that represent this is: 1 &lt;&lt; ( 0x115 - 0x100). = 0x200000</p><p><br/>ABS_WHEEL (not mentioned in the tables above) is 0x8, so its mask is 0x100.</p><p>ABS_GAS (also not mentioned in the tables above) is 0x9, so its mask is 0x200.</p><p>If we had ABS_WHEEL and ABS_GAS its bitmask would be 0x100 | 0x200 = 0x300.</p><p><span class=\"mw-headline\"><br/></span></p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}