{
    "id": "confluence-214",
    "title": "VHD Encryption",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/28540934/VHD+Encryption",
    "content": "<p>Owned by Ross Philipson\nLast updated: Aug 22, 2016 by Ross Philipson\n\n</p><ac:structured-macro ac:macro-id=\"8b686237-640b-4a99-aad7-c28571c6b798\" ac:name=\"info\" ac:schema-version=\"1\"><ac:parameter ac:name=\"icon\">None</ac:parameter><ac:rich-text-body><p><ac:image ac:width=\"80\"><ri:attachment ri:filename=\"cc-by.png\"></ri:attachment></ac:image></p><p>Copyright 2014 by Citrix Systems, Inc. This work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy of this license, visit <a class=\"external-link\" href=\"http://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\">http://creativecommons.org/licenses/by/4.0/</a>.</p></ac:rich-text-body></ac:structured-macro><p><span style=\"color: rgb(37,37,37);\"><ac:structured-macro ac:macro-id=\"550d6df4-b693-424a-a7b9-8c9af6e409d2\" ac:name=\"toc\" ac:schema-version=\"1\"></ac:structured-macro><br/></span></p><p><span style=\"color: rgb(37,37,37);\">This page is for general data on encrypted VHDs. I'm starting out with simple things like how to manually create an encrypted VHD, how to load one directly using </span><code style=\"line-height: 1.42857;\">blktap2</code><span style=\"color: rgb(37,37,37);\"> and </span><code style=\"line-height: 1.42857;\">tap-ctl</code><span style=\"color: rgb(37,37,37);\"> and whatever else comes to mind. Feel free to add relevant content.</span><span style=\"color: rgb(37,37,37);\"> </span></p><h2><span class=\"mw-headline\">Supported Algorithms</span></h2><p>To create an encrypted VHD we've extended <code>vhd-util</code> with the <code>key</code> command. It's pretty simple to use but first things first: we need an encryption key. We support what is typically referred to as AES-XTS-PLAIN. That means that AES is the encryption, XTS is the 'mode' for the AES algorithm, and PLAIN refers to the method by which initialization vectors are created. Since VHDs have a 2TB limit we use plain instead of plain64.</p><h2><span class=\"mw-headline\">Keys</span></h2><p>Further we support either AES 128 or 256. <code>blktap2</code> selects the algorithm on start-up based on the size of the key used. One of the fun things about AES is that the key size needs to be twice that of the number associated with the algorithm. So for AES 256 you'll need a 512 bit key. So since the <code>dd</code> command operates in bytes we need either a key 32 or 64 bytes in size.</p><p>Let's assume our VHD is going to be called '<code>crypt.vhd</code>'. From a shell in dom0:</p><pre>$ dd if=/dev/urandom of=/config/platform-crypto-keys/crypt,aes-xts-plain,512.key bs=64 count=1\n</pre><p>In this example I made a 512 bit key by reading 64 bytes from <code>/dev/urandom</code>. This key will cause <code>blktap2</code> to use AES 256. If you want to use AES 128 read 32 bytes and substtitue 256 for 512 in the file name for the key. This format of this file name is significant so don't mess it up.</p><h2><span class=\"mw-headline\">Create an Encrypted VHD</span></h2><p>To create an encrypted VHD you only need to associate a key with the VHD and <code>blktap2</code> will do the rest. So first things first we need to create a VHD. Let's make a 512MB VHD and call it '<code>crypt.vhd</code>'. We'll put it in <code>/storage/disks</code> for good form:</p><pre>$ vhd-util create -n /storage/disks/crypt.vhd -s 512\n</pre><p>Now we take the key we created in the the previous section and associate it with the VHD. We'll start out with the easy way:</p><pre>$ vhd-util key -s -n /storage/disks/crypt.vhd -k /config/platform-crypto-keys/crypt,aes-xts-plain,512.key\n</pre><p>The command above takes the <code>sha256</code> hash of the key and stores this hash in the VHD header. This allows <code>blktap2</code> be sure it's using the right key when loading an encrypted VHD. Additionally we can use what <code>vhd-util</code> calls a <code>nonce</code>. This is really called a '<code>salt</code>' in all the literature. Your salt should be the same size as the output of the hash function so for <code>sha256</code> it should be 32 bytes. Using a salt is left as an exercise for the interested reader. Take a look at the help output by <code>vhd-util key</code> for other possibilities.</p><p><strong>Note</strong>: TODO</p><h2><span class=\"mw-headline\">Mount an Encrypted VHD in dom0</span></h2><p>There are a few command sequences you can go through to accomplish this. We'll start with the simple approach and then go into a more complicated approach that's useful if you're debugging <code>blktap2</code>.</p><h3><span class=\"mw-headline\">The Easy Way</span></h3><p>There are a number of steps required to get <code>blktap2</code> to set everything up and give us a device node in <code>/dev/xen/blktap-2</code> that's attached to our VHD. There's a command that wraps all of these into a single step for ease of use and we'll start there:</p><pre>$ tap-ctl create -a vhd:/storage/disks/crypt.vhd\n</pre><p>Check your return status and you'll probably get a '<code>126</code>'. Look in <code>/var/log/messages</code> and you'll see that <code>blktap2</code> requires that the environment variable '<code>TAPDISK2_CRYPTO_KEYDIR</code>' be set to the directory where it should look for key files. So export this and the above command should work as expected but this time it will output the path to the device node that's been created for our VHD. You can partition this / make filesystems on it / mount and interact with it like any other block device.</p><h3><span class=\"mw-headline\">The Hard Way</span></h3><p>Say you're debugging some stuff in the <code>tapdisk</code> daemon and you've added some test code that dumps a bunch of stuff to the terminal to help you trace through some code path. The Easy Way shown above causes <code>tapdisk2</code> to daemonize itself and run in the background so you won't be able to see any of your output. Alternatively you can manually kick off your <code>tapdisk2</code> process keeping it in the foreground and attached to the console:</p><pre>TAPDISK2_CRYPTO_KEYDIR=/config/platform-crypto-keys tapdisk2 -D\n</pre><p>Now you'll get your output but you can no longer use the shortcut <code>tap-ctl create</code> command. Instead we need to manually walk through the steps that are wrapped by <code>tap-ctl create</code> in a new shell. The command above will output the PID of the <code>tapdisk2</code> process we've started and we'll just call this <code>PID</code> from here on. Scripting this would look like so:</p><pre>$ MINOR=$(tap-ctl allocate | sed -e 's&amp;^\\/dev\\/xen\\/blktap-2\\/tapdev\\([0-9]\\+\\)$&amp;\\1')\n$ tap-ctl attach -p ${PID} -m ${MINOR}\n$ tap-ctl open -p ${PID} -m ${MINOR} -a vhd:/storage/disks/crypto.vhd\n</pre><p>First we allocate a device node that initially will have no storage backing it. The <code>allocate</code> command will output the path to the device node and we run that through sed to get the minor device number. Next we attach the <code>tapdisk2</code> process we started on the other terminal to this device node with the <code>attach</code> command. Then we tell that <code>tapdisk2</code> daemon to open our VHD and associate it with the same device that we just attached it to with the <code>open</code> command.</p><p>Once you're done with your debugging you can run the inverse of these commands in the reverse order: <code>close</code>, <code>detach</code> and <code>deallocate</code>. Once you <code>detach</code> your <code>tapdisk2</code> daemon from the device node it will shutdown so fair warning.</p><p>This approach gives us the most flexibility but really isn't necessary unless you're gonna be debugging <code>tapdisk2</code>.</p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}