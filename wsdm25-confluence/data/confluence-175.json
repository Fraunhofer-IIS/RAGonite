{
    "id": "confluence-175",
    "title": "Toolstack Guide",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/15368227/Toolstack+Guide",
    "content": "<p>Owned by Ross Philipson\nLast updated: Aug 14, 2018 by Tim Konick\n\n</p><p class=\"auto-cursor-target\"><br/></p><ac:structured-macro ac:macro-id=\"8b686237-640b-4a99-aad7-c28571c6b798\" ac:name=\"info\" ac:schema-version=\"1\"><ac:parameter ac:name=\"icon\">None</ac:parameter><ac:rich-text-body><p><ac:image ac:width=\"80\"><ri:attachment ri:filename=\"cc-by.png\" ri:version-at-save=\"1\"></ri:attachment></ac:image></p><p>Copyright 2013 by Citrix Systems, Inc. This work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy of this license, visit <a class=\"external-link\" href=\"http://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\">http://creativecommons.org/licenses/by/4.0/</a>.</p></ac:rich-text-body></ac:structured-macro><p><br/></p><p><ac:structured-macro ac:macro-id=\"3fa5235e-fb65-4c8a-96e7-6189297b1cba\" ac:name=\"toc\" ac:schema-version=\"1\"></ac:structured-macro></p><h2>Introduction</h2><p>This page is intended to document the OpenXT toolstack. Please feel free to contribute heavily.</p><h2>xec / xec-vm</h2><p>These are small haskell programs. Xec is a generic dbus access utility, similar to dbus-send, can be used to communicate with any dbus daemon though defaults to communication with xenmgr. Xec-vm is a wrapper around xec which is VM aware. Both have decent \"--help\" toggles.</p><h2>Database daemon</h2><p>Database daemon (dbd) is a small ocaml/dbus aplication which handles persistence of OpenXT configuration data. The database files are stored in /config/db and /config/vms.</p><p>The dbd reads config files (which are in json format) at startup and creates an in-memory representation of the database, which is primarily a simple tree of strings similar to xenstore. From now on it proceeds to work on memory representation only, marking it dirty in case of modifications. The dirty trees are flushed to disk in 3s intervals. Dbd features protection against power cuts / partial writes. It always flushes to temporary file first, then atomically renames the temporary file.</p><h3>API presented by dbd</h3><ul><li><code>+ read ( path:s, OUT value:s )</code> reads a string value at given path</li><li><code>+ read-binary ( path:s, OUT value:ay )</code> reads byte array value at given path</li><li><code>+ write ( path:s, value:s )</code> writes string value to given path</li><li><code>+ dump ( path:s, OUT value:s )</code> dumps whole json subtree at given path *<code>+ inject ( path:s, value:s )</code> writes whole json subtree to given path</li><li><code>+ list ( path:s, OUT value:as )</code> lists child nodes at given path</li><li><code>+ rm ( path:s )</code> removes subtree at given path</li><li><code>+ exists ( path:s, OUT ex:b )</code> checks if a subtree/value at given path exists</li></ul><h2>RPC proxy</h2><p>RPC proxy is a haskell application which supports proxying and filtering of RPC traffic used in OpenXT. The proxied traffic consists of either binary dbus (for most use cases) or json/websocket based dbus (for conversations with a web browser in the UIVM) and is transported using UNIX domain sockets or v4v sockets.</p><p>There are 3 instances of rpc-proxy running by default in Dom0, each of them having different function:</p><p><code>/usr/bin/rpc-proxy -s</code></p><p>This one forwards data between default incoming channel (v4v port 5555) to default outgoing channel (UNIX socket /var/run/dbus/system_bus_socket). The effect is that it's possible for any VM to connect to v4v port 5555 of Dom0 and get access to its system bus. Similar to connecting locally within the VM by binding the UNIX socket. V4V port 5555 is exposed only to reasonably trusted service VMs, such as NDVM and SyncVM since it's possible to export new services on the Dom0 bus by connecting to it. Rpc-proxy makes the decision whether to forward or drop messages based on the default rules file in /etc/rpc-proxy.rules</p><p><code>/usr/bin/rpc-proxy -i v4v:5556 -n com.citrix.xenclient.guest.uuid_$UUID --translate-anonymous-dests</code></p><p>This one is similar to the one above however slightly more \"secure\" and therefore exposed to user VMs as well. It forwards data between v4v port 5556 to the default outgoing channel (UNIX socket /var/run/dbus/system_bus_socket). The \"-n com.citrix.xenclient.guest.uuid_$UUID\" arguments causes any attempt to export named service on Dom0 to force a rename of the service to com.citrix.xenclient.guest.uuid_$UUID. Therefore, a guest connecting to this port can only export one service. This has been useful in the past for implementing an agent in Linux VMs exporting guest power management operations. This may have been replaced by xenstore/pv driver based functionality.</p><p><code>/usr/bin/rpc-proxy -i v4v:8080 --json-in --websockets-in -n com.citrix.xenclient.guest.uuid_$UUID --auto-auth</code></p><p>This one listens on v4v port 8080 and forwards to default outgoing channel (UNIX socket /var/run/dbus/system_bus_socket). It expects incoming data in json format (--json-in) wrapped in websocket protocol (--websockets-in). It limits ability to export service names on Dom0 bus via \"-n com.citrix.xenclient.guest.uuid_$UUID\". This is used for communications with browsers used in UIVM. \"--auto-auth\" is just a shortcut to avoid the browser having to do dbus authentication, rpc-proxy will do it on its behalf (we don't use dbus authentication for any security purposes, all it does is state that we are connecting as root).</p><h3>RPC rules format</h3><p>The default rpc rules are stored in /etc/rpc-proxy.rules file. Extra rules can be attached to VM config trees and will take effect when the VM is started and be torn down when the VM is stopped. The format of the rules is relatively straightforward, for example:</p><ac:structured-macro ac:macro-id=\"3b700e72-6193-4e9c-9143-bd29c453391b\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">bash</ac:parameter><ac:plain-text-body><![CDATA[# nothing can be done by default\ndeny all\n\n# allow stubdoms to talk to surfman,xenmgr,dbus\nallow stubdom true destination com.citrix.xenclient.surfman\nallow stubdom true destination com.citrix.xenclient.xenmgr\nallow stubdom true destination org.freedesktop.DBus interface org.freedesktop.DBus\n\n# allow guests to call 'gather' on diagnostics interface (required by xc-diag)\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.diag member gather\n\n# allow anybody to do some vm queries required for switcher bar\nallow destination com.citrix.xenclient.xenmgr interface org.freedesktop.DBus.Properties member Get\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr member list_vms\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.vm member get_db_key\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.vm member read_icon\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.vm member switch\nallow destination com.citrix.xenclient.input interface com.citrix.xenclient.input member get_focus_domid\nallow destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr member find_vm_by_domid\n\n# allow guest to do some requests allow destination \ncom.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.guestreq member request_attention\n\n# allow conditional domstore (private db space) access \nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member read if-boolean domstore-read-access true\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member read_binary if-boolean domstore-read-access true\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member list if-boolean domstore-read-access true\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member exists if-boolean domstore-read-access true\n\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member write if-boolean domstore-write-access true\nallow destination com.citrix.xenclient.db interface com.citrix.xenclient.db member rm if-boolean domstore-write-access true]]></ac:plain-text-body></ac:structured-macro><ul><li><p>Only allow/deny rules are supported. The rule type specification is followed by a dbus message matcher where \"destination \" \"interface \" and \"member \" can be specified to match the corresponding fields of an incoming dbus message.</p></li><li><p>stubdom rules</p></li></ul><p>Of some interest are stubdom rules marked as \"stubdom true\". They only match on messages coming from stub domains.</p><ul><li><p>rules based on configuration of VM sending the message It is also possible to make rules based on any boolean fields in an incoming VM config tree. In the example above \"if-boolean domstore-read-access true\" matches only if the VM which has sent the message has a \"domstore-read-access\" boolean config in its tree set to true. Therefore, it is possible to disable/enable VM's domstore access (which boils down to allowing it to access dbd remotely) simply by manipulating its config tree.</p></li><li><p>rules based on domain type Sometimes it's useful to grant rpc permission to all VMs of particular type (such as \"NDVM\", \"SyncVM\"). This can be achieved by adding \"dom-type \" matcher to the rule, for example: allow dom-type syncvm destination com.citrix.xenclient.xenmgr interface com.citrix.xenclient.xenmgr.vm member add_disk</p></li></ul><h2>xenvm</h2><p>xenvm is a single virtual machine monitor, written in Ocaml. It's forked on per-vm basis, and responsible for its lifecycle and control operations. It interacts directly with Xen via the libxenctrl wrapper. You can find it in toolstack.git.</p><p>TODO: Which layers of xenvm have state? If xenvm is killed should the domain die? Can xenvm be restarted while a domain continues running? Should xenvm instances exist for VMs which are not running?</p><p>Xenvm is a stateful daemon:</p><ul><li>upper layers hold the VM config state in memory</li><li>upper layers hold the VM state in memory</li></ul><p>The lower layers (such as xenops / device layer) primarily rely on state stored in xenstore, mostly by PV drivers, and don't hold in-memory state (they do tend to write [and later read] some small extra state bits to xenstore [rarely]).</p><p>It does run even if the VM is not running, providing the ability to configure a VM in its \"stopped\" state. However, as a boot performance optimization, it's only started for the first time when the 1st request to start a VM it handles is created. Then it continues to run until system shutdown (or VM deletion). Xenmgr copes with it by delaying the initial configuration.</p><p>The state of a VM reported by xenvm is partially taken from domain state reported by Xen as well as partially derived by xenvm. Xen doesn't report exact domain states when it notifies the dom0 toolstack about a state change (via event channel), it basically just gives a notification that \"something has happened\" and it's the job of xenvm to check on each VM whether it's still running, or died etc and update its internal state accordingly (and then forward it to upper layers of toolstack, that is xenmgr).</p><p>Xenvm cannot be restarted when a domain is running, that is the limitation of how it's coded at the moment (stateful). It can be restarted when domain is dead, but xenvm does not automatically quit when a domain dies (and shouldn't).</p><h2>Code Layout</h2><h3>Libraries</h3><ul><li>libs/common - various utilities</li><li>libs/eventchn - binding for libxenctrl's eventchannel interfaces</li><li>libs/json - json parser</li><li>libs/stdext - utility extensions for Ocaml's standard library</li><li>libs/uuid - uuid generation and handling</li><li>libs/xc - libxenctrl binding</li><li>libs/xg - libxenguest binding</li><li>libs/xs - native ocaml xenstore protocol implementation</li></ul><h3>Scripts</h3><p>There are few udev scripts in \"scripts\" subfolder, as well as udev rules for executing these scripts. These handle the notifications to the toolstack that the backend PV drivers have completed creating network/disk devices, or tearing them down.</p><h3>Xenops</h3><p>Xenops is the lower-layer part of xenvm, responsible for lower level management of Xen domains (via domain ids). It is both used internally by xenvm as well as exposed to the user via the \"xenops\" Dom0 utility.</p><ul><li>xenops/balloon.ml - memory ballooning utilities, not used much in OpenXT</li><li>xenops/device.ml and device_common.ml - important files which are responsible for initialization of PV (or PCI passthrough) device backends (via xenstore)</li><li>xenops/dm.ml - config construction for qemu</li><li>xenops/dmagent.ml - communication with dmagent, which is a program used to fork/configure qemu instances (which can be running in another domain)</li><li>xenops/domain[_common].ml - domain management functions</li><li>xenops/hotplug.ml - few utility functions to wait on device being created by PV backend etc</li><li>xenops/memory.ml - crazy arithmetic to figure out how much memory is required to boot a VM</li><li>xenops/netman.ml - couple network helper functions</li><li>xenops/watch.ml - xenstore watch helper functions</li><li>xenops/xal.ml - low level loop waiting and parsing PV device events</li></ul><h3>Xenvm</h3><ul><li>xenvm/misc.ml - as name says</li><li>xenvm/tasks.ml - list of rpc tasks xenvm supports</li><li>xenvm/vmact.ml - high level implementation of vm operations (start/stop etc)</li><li>xenvm/vmconfig.ml - parsing xenvm config files (in OpenT, placed in /tmp/xenmgr-xenvm-*)</li><li>xenvm/vmstate.ml - VM state struct</li><li>xenvm/xenops.ml - xenops Dom0 utility entry point</li><li>xenvm/xenvm.ml - daemon entry point</li></ul><h2>xenmgr</h2><p>xenmgr is a haskell application which exports VM configuration over DBus and translates it to lower level configuration files consumed by xenvm. Since xenvm is a single virtual machine monitor, xenmgr is reponsible for some cross-vm concepts, such as relocating network PV backend on backend domain reboot, VM dependencies, enforcing cross-vm v4v firewall rules etc.</p><p>TODO: detail the concurrency model (e.g. thread per dbus connection, reactor or whatever). What are the consequenes of killing and restarting xenmgr? What normally launches xenmgr?</p><p>Xenmgr is started by the \"bootage\" Dom0 program, similarly to many other Dom0 daemons (configured in /etc/bootage.conf). Xenmgr is fully reusable since it doesn't keep almost any in-memory VM state. The only consequence is a temporary DoS on its functionality as well as the possibility of some startup code executing again, which includes for example locking the UIVM with authentication screen, or performing boot-time service VM filesystem checksum.</p><p>Each incoming RPC call to xenmgr is processed in parallel (called haskell IO thread). Because most of the state is kept outside of xenmgr (either in db or xenstore), there isn't much synchronization needed. Still, because the dbd doesn't support transactions some db writes need to be protected by locking. Xenmgr provides this capability.</p><p>Unlike incoming calls, incoming notifications are processed serially on a separate IO thread. This is because the ordering of notifications is important (and guaranteed by dbus, therefore we have to process them serially to keep the guarantee). As a consequence, long running notification handlers should be forking off a thread to not block the queue.</p><h3>exported DBus entities</h3><p>xenmgr exports following dbus objects:</p><ul><li>/ - root object, contains global configuration and operations</li><li>/vm/$VM_UUID - per VM dbus object, provides access to VM configuration</li><li>/vm/$VM_UUID/$DISK_ID - provides access to VM disk configuration</li><li>/vm/$VM_UUID/$NIC_ID - provides access to VM network interface configuration</li><li>/host - provides access to host specific configuration and host information</li></ul><p>each of these objects exports one or more dbus interfaces, as defined in IDL repository (idl.git). Following IDL files are used by xenmgr</p><ul><li>xenmgr.xml</li><li>xenmgr_vm.xml</li><li>xenmgr_host.xml</li><li>vm_nic.xml</li><li>vm_disk.xml</li></ul><h3>DBus interface boilerplate generation</h3><p>Most of dbus boilerplate code, such as the hooks to implement exported functions as well as stubs for calling other daemons is generated from the files in idl.git by a custom written program \"rpcgen\". It takes dbus xml files as input and produces binding/hooks in variety of languages as output.</p><p>In case of xenmgr the boilerplate is generated from its BB recipe, in the configure step:</p><ac:structured-macro ac:macro-id=\"29632ecc-a375-4e58-b759-16556d5cdaa3\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">bash</ac:parameter><ac:plain-text-body><![CDATA[# generate rpc stubs\nmkdir -p Rpc/Autogen\n# Server objects\nxc-rpcgen --haskell -s -o Rpc/Autogen --module-prefix=Rpc.Autogen ${STAGING_DATADIR}/idl/xenmgr.xml\nxc-rpcgen --haskell -s -o Rpc/Autogen --module-prefix=Rpc.Autogen ${STAGING_DATADIR}/idl/xenmgr_vm.xml]]></ac:plain-text-body></ac:structured-macro><p>Hence usually modification of IDL consists of following steps:</p><ul><li>modify IDL files</li><li>re-stage IDL files (for example by ./bb -cforce_rebuild xenclient-idl &amp;&amp; ./bb xenclient-idl)</li><li>regenerate boilerplate (./bb -cconfigure xenmgr)</li><li>compile xenmgr (./bb -ccompile xenmgr), fix errors, add implementation for new methods etc</li></ul><h3>VM templates</h3><p>There's a bunch of json templates in the \"templates\" subfolder; on the device they are installed in /usr/share/xenmgr-1.0/templates. There are basically two types of templates:</p><ul><li><p>service VM template, distinguished via \"service-\" prefix in file name. On each boot, the toolstack will create a VM instance based on these (which will be visible via xec-vm contrl utility). If the same instance was already present, its config will be overwritten each boot which generally makes for an easy upgrades of service VM config files (default NDVM or UIVM)</p></li><li><p>all other templates. VM instances based on these will only be created by manual request (either from UIVM creation wizard, or one of the xec create-vm-* functions)</p></li></ul><p>It's sometimes handy to turn off the automatic overwrite of service VM templates each xenmgr start, so that the service VM can be reconfigured via manual xec-vm invocations. This can be achieved via</p><p><code>$ db-write /xenmgr/overwrite-&lt;vmtype&gt;-settings false</code></p><p>for example for NDVM: db-write /xenmgr/overwrite-ndvm-settings false</p><h3>VM configuration</h3><p>JSON vm configuration files are stored in /config/vms/ though xenmgr doesn't access them directly but rather through dbd's dbus API. Low level configuration files consumed by xenvm (which are output by xenmgr) reside in /tmp/xenmgr-xenvm-$VM_UUID files.</p><h3>VM properties</h3><p>VM properties are declared in idl.git, in interfaces/xenmgr_vm.xml. Most of them are documented. Any additional documentation should go to IDL files since that's also the place from which sdk docs are generated.</p><h3>Dodgy VM properties</h3><p>There are some VM properties which have non trivial repercussions and warrant additional clarification:</p><ul><li>xci-cpuid-signature</li></ul><p>Setting it to true changes CPUID signature reported by Xen to be xenclient specific. Effectively it hides Xen presence from the guest. We use it on Linux VMs to avoid the default PV drivers in upstream kernels from activating (so that we can use custom ones). However, toggling it off enables the usage of upstream drivers, if needed.</p><ul><li>flask-label</li></ul><p>This specifies the SELinux security context under which VM runs, if mismatched it can prevent the VM from being able to issue hypercalls required for its normal function.</p><ul><li>provides-network-backend</li></ul><p>Tells xenmgr to treat this VM as network VM; it will send notifications about VM, or VM state to the network daemon.</p><ul><li>greedy-pciback-bind</li></ul><p>This activates the behavior of greedily seizing devices which are configured for PCI passhthrough by any VM by pciback driver on OpenXT boot. This behavior is different from the upstream one, however it is useful to prevent Dom0 drivers using the devices which might later be used for pass-through.</p><p>Audio driver is a good example; if the audio card is not seized by pciback driver at boot, alsa drivers in Dom0 will take it over which might prevent pass-through from working correctly later when the PCI passthrough VM is started.</p><h3>VM hooks</h3><p>xenmgr supports offloading some of its functionality to either a script, or another dbus daemon (possibly running in different VM). This is done via the following VM hooks (implemented as regular VM properties):</p><ul><li>run-post-create</li><li>run-pre-delete</li><li>run-pre-boot</li><li>run-insteadof-start</li><li>run-on-state-change</li><li>run-on-acpi-state-change</li></ul><p>Each hook can be either a script name, for example: <code>xec-vm -n foo set run-insteadof-start /bin/customstart</code></p><p>or a string specifying the dbus rpc call to make, example:</p><p><code>$ xec-vm -n foo set run-insteadof-start rpc:vm=$SOME_UUID,destination=com.citrix.some.service,interface=com.citrix.iface,member=com.citrix.some.method</code></p><p>both the script and rpc call gets passed to the affected VM uuid as its sole argument.</p><h3>PCI passthrough rules</h3><p>VM passthrough rules are specified by a set of matchers, which are evaluated when VM starts to find actual PCI devices which need to be PT-ed.</p><p>VM PCI passthrough rules are managed by the following dbus methods:</p><ul><li><p>add_pt_rule Adds a new passthrough rules. each of the matchers can take either an ID or word \"any\" which means match on all devices. example:</p><p><code>xec -n somevm add-pt-rule 0x680 any any</code></p></li><li><p>add_pt_rule_bdf Adds a new passthrough rule using BDF notation, example:</p><p><code>xec -n somevm add-pt-rule-bdf 0000:00:16.0</code></p></li><li><p>delete_pt_rule, delete_pt_rule_bdf - removal of passthrough rules</p></li><li>list_pt_rules - lists current passthrough rules</li><li>list_pt_pci_devices - evaluates all vm passthrough rules and outputs lists of matching pci devices on host</li></ul><h3>V4V firewall rules</h3><p>V4V firewall rules are managed by dbus api similarily to PCI passthrough rules and evaluated when the VM starts. They usually result in a series of calls to \"viptables\" command-line program to erect the firewall. On VM shutdowns, the entries added during VM start are torn down.</p><p>V4V firewall rules can be modified via add_v4v_firewall_rule / delete_v4v_firewall_rule methods. These take a string argument with a rule definition. The format of rule string is as follows:</p><p><code>&lt;source&gt; -&gt; &lt;destination&gt;</code></p><p>the format of each of the source/destination endpoints is</p><p><code>( * | my-stubdom | myself | dom-type=&lt;domaintype&gt; | dom-name=&lt;domainname&gt; ) : &lt;v4v port&gt;</code></p><p>examples:</p><ul><li>open connection from the VM to domain's 0 port 5555: myself-&gt; 0:555</li><li>open connection from the VM to all domains of type \"ndvm\" port 5555: myself -&gt; dom-type=ndvm:5555</li><li>open connection from VM's stubdom to domain 0 port 333: my-stubdom -&gt; 0:333</li></ul><h2>VM measurement</h2><p>If the \"measured\" property in the VM config tree is set, the first disk (ID 0) will is evaluated for checksum consistency and its hash is stored in the VM config tree. This is done by mounting the filesystem and computing a sha256 hash of the filesystem (as opposed to doing it on VHD file; because even readonly VHD files are modified due some bookkeeping information such as access timestamp).</p><p>If a hash inconsistency is detected, a measurement failure action will be invoked. It defaults to shutting down the system. It can be overridden via</p><p><code>$ db-write /xenmgr/measure-fail-action &lt;powermanagementaction&gt;</code></p><p>can be one of the following</p><ul><li>sleep</li><li>hibernate</li><li>shutdown</li><li>forced-shutdown</li><li>reboot</li><li>nothing</li></ul><p>and, as mentioned before, defaults to forced shutdown if not specified</p><h2>VM dependencies</h2><p>xenmgr supports a simple form of dependency tracking between VMs. If a VM is configured such that its network backend is not in Dom0, xenmgr will internally track that dependency. It's possible to list all the VMs dependencies by</p><p><code>$ xec-vm -n somevm list-dependencies</code></p><p>By default when a VM is started, xenmgr will ensure all its dependencies are started first. This can be toggled off via setting \"track-dependencies\" VM property to false.</p><p>There's no automatic shutdown of dependent VMs.</p><h2>Power Management</h2><p>Xenmgr supports some configuration of power related operations</p><ul><li>vm property \"s3-mode\"</li></ul><p>This configures how the toolstack handles requests to put a VM to S3. Note that this doesn't affect requests made from within guest, but just requests originating from the UI / closing the laptop lid etc. It can be one of the following:</p><ol><li>ignore - request to put VM to S3 will be ignored, toolstack will proceed to the next VM on the list</li><li>PV - toolstack will ask the PV driver within the guest to put it to S3 via xenstore. This is the default for most VMs</li><li><p>restart - toolstack will shutdown the VM and start it again after S3 resume. This is useful for NDVM.</p></li></ol><ul><li>vm property \"s4-mode\"</li></ul><p>Supports exactly same ability to configure as \"s3-mode\", specifies actions to be taken when the toolstack is supposed to put VM to hibernate.</p><ul><li>vm property \"control-platform-power-state\"</li></ul><p>This is useful for some single-vm scenarios. The toolstack will track guest power state and try to put host to the same state. So if the guest goes to S3, toolstack will put the host to S3 as well.</p><ul><li>host methods \"set_ac_lid_close_action\", \"set_battery_lid_close_action\"</li></ul><p>Configure the power action performed when laptop lid closes, either on battery or AC adapter. Can be one of the following:</p><ul><li>sleep</li><li>hibernate</li><li>shutdown</li><li>forced-shutdown</li><li>reboot</li><li>nothing</li></ul><h2>Code layout</h2><p>Xenmgr is split into a small library (xenmgr-core) and main daemon (xenmgr). xenmgr-core atm contains very little, primarily just a bit of v4v firewall rule parsing code. The intent was to move code useful for other projects (such as the OVF import tool) out of xenmgr daemon and into the library.</p><h3>Custom Libraries Used</h3><p>There's a bunch of small haskell libraries we wrote which are in use by toolstack components. They reside in xclibs.git.</p><ul><li>udbus - vincent's small dbus library</li><li>xchv4v - v4v access library</li><li>xch-rpc - higher level rpc library based on udbus, also with support for v4v rpc tunnels</li><li>xchdb - access to database files in /config, thru database daemon</li><li>xchutils - various random useful utility code</li><li>xchwebsocket - websocket library used by rpc-proxy</li></ul><h3>xenmgr-core</h3><ul><li>Vm/Uuid.hs - few functions related to handling UUIDs</li><li>Vm/ProductProperty.hs - handling OVF product properties (not used much atm besides theoretically for VMs defined by OVF xml)</li><li>Vm/V4VFirewall.hs - parsing of v4v firewall rules</li></ul><h3>xenmgr</h3><ul><li>Rpc/Autogen - folder containing all rpc access stubs generated by rpcgen (invoked from bb recipe)</li><li>Tools/* - various utility code</li></ul><h4>Vm subtree</h4><ul><li>Vm/Types.hs - definition of important types, such as definition of vm config and vm states</li><li>Vm/Monad.hs - definition of \"Vm\" monad which is a simple reader-based monad that implicitly holds context for single vm</li><li>Vm/Config.hs - definition of database location for all vm config properties and code to create lower-level xenvm config files</li><li>Vm/State.hs - vm state conversions from/to string as well as introduction of concept of internal vm state, which is a vm state private to xenmgr and more detailed than the generic state exposed from xenvm</li><li>Vm/Dm.hs, DmTypes.hs - types relating to device model, such as disks, nics, xenstore device states, handling backend/frontend interactions</li><li>Vm/DomainCore.hs - handling domids/lookup of domains and their stubdoms</li><li>Vm/Balloon.hs - balloning service vm memory down (if allowed by vm config, which it's usually not)</li><li>Vm/Pci*.hs - PCI passthrough - parsing pci passthrough rules, handling of binding drivers to pciback</li><li>Vm/DepGraph.hs - few graphing utilities to solve the dependency graph between vms (even though it usually boils down to 2 node graphs...)</li><li>Vm/Policies.hs - storage and query of vm policy settings</li><li>Vm/Monitor.hs - code for monitoring vm events from various sources (xenvm and xenstore) and registering/invoking internal handlers</li><li>Vm/React.hs - event handlers for vm events coming from Monitor.hs</li><li>Vm/Templates.hs - finding, categorizing, reading vm and service vm templates (in /usr/share/xenmgr-1.0/templates)</li><li>Vm/Queries.hs - many passive functions to query about vm states/config. Of particular interest would be \"getVmConfig\" functions which creates in-memory config representation based on database</li><li>Vm/Actions.hs - active functions for changing vm config as well as doing some runtime state manipulation (such as relocating network backend to different ndvm), starting/stopping vms etc</li></ul><h4>XenMgr subtree</h4><ul><li>XenMgr/Connect/* - wrappers to access other daemons in the system</li><li>XenMgr/Expose/* - entry points for all xenmgr's dbus server rpcs</li><li>XenMgr/CdLock.hs - relatively new code for handling the AFRL request cd drive lock model</li><li>XenMgr/Config.hs - global xenmgr config storage/query</li><li>XenMgr/Diagnostics.hs - gathering status reports from vms + other diagnostics</li><li>XenMgr/Diskmgr.hs - vhd creation</li><li>XenMgr/Errors.hs - definition of numbered errors reported to the UI</li><li>XenMgr/Host.hs - lots of host level query functions (eth0 mac adresses, bios versions, xc versions, update state etc)</li><li>XenMgr/HostOps.hs - host shutdown/sleep/hibernate/reboot entry points</li><li>XenMgr/PowerManagement.hs - actual implementation of host shutdown/sleep/hibernate/reboot etc plus code to handle lid state changes</li><li>XenMgr/Notify.hs - wrappers for easier generation of various dbus signals</li><li>XenMgr/Rpc.hs - definition of Rpc monad used in xenmgr for dbus access</li><li>XenMgr/XM.hs - definition of XM monad based on reader monad containing context for<em>all</em> vms. Useful for doing some cross vm interactions which require locking / synchronization</li></ul><h2>Interactions with other daemons</h2><p>xenmgr interacts with the following daemons on system:</p><ul><li>database daemon (dbd) for config storage. Via DBUS only.</li><li>xenvm for all low level vm operations / domain creation / shutdown etc. Via DBUS and textual vm config files in /tmp/xenmgr-xenvm-$UUID</li><li>input daemon for handling on-boot authentication screen, vm focus switching, screen lock, seamless mouse configuration. Via DBUS.</li><li>network daemon to notify it about state for vms marked with \"provides-network-backend\" property. Via DBUS (over v4v into network domain)</li><li>surfman to query it for list of passthrough GPU devices if using PVMs (\"get_vgpu_mode\" surfman RPC). Via DBUS.</li></ul><h3>apptool</h3><p>Apptool is an OVF (open virtualization format) import tool. More info at<a href=\"https://en.wikipedia.org/wiki/Open_Virtualization_Format\">https://en.wikipedia.org/wiki/Open_Virtualization_Format</a> and <a href=\"https://github.com/OpenXT/manager/tree/master/apptool\">https://github.com/OpenXT/manager/tree/master/apptool</a>.</p><h1>XenVM cont.</h1><p>There is some more documentation buried in the toolstack repository. I added it - for convenience purposes - here.</p><p>Xenvm is a single VM monitor. it's a single process that follow the life of a VM, and open a command socket where you can send command, just like xm to xend.</p><p>xenvm expose the uuid of the domain to outside world, so instead of having to refer to the domid of the domain, all outside command use the uuid. the uuid beeing stable, all command will use the same uuid after reboot/suspend/resume cycle.</p><h1>Config file</h1><p>you can put the following parameters in your config file:</p><p>(common options)</p><table class=\"wrapped\"><thead><tr><th>key name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>hvm</td><td>s</td><td>command line given to the kernel</td></tr><tr><td>startup</td><td>s</td><td>specify what to do with the domain at startup possibles value: started, paused, shutdown or restore</td></tr><tr><td>debug</td><td>b</td><td>logs all operations to /tmp/xenvm-debug-%uuid</td></tr><tr><td>uuid</td><td>s</td><td>specify the domain uuid (default to autogeneration)</td></tr><tr><td>on_crash</td><td>s</td><td>specify the action to be taken after notifying a</td></tr><tr><td>on_halt</td><td>s</td><td>crash/halt/reboot. possible values:</td></tr><tr><td>on_reboot</td><td>s</td><td>preserve, reboot, destroy</td></tr><tr><td>kernel</td><td>s</td><td>specify where to find the kernel to boot (can be empty for hvm. default to hvmloader)</td></tr><tr><td>memory</td><td>i</td><td>specify the memory given to the guest in megabytes</td></tr><tr><td>vcpus</td><td>i</td><td>number of vcpus available to the guest</td></tr><tr><td>disk</td><td>s</td><td>add a virtual disk.</td></tr><tr><td><br/></td><td><br/></td><td>format: physpath:phystype:virtpath:mode:devty[:k=v...]</td></tr><tr><td><br/></td><td><br/></td><td>- physpath: path to the disk image, raw device, ..</td></tr><tr><td><br/></td><td><br/></td><td>- phystype: phy</td></tr><tr><td><br/></td><td><br/></td><td>- virtpath: hd(a-d)</td></tr><tr><td><br/></td><td><br/></td><td>- mode: r</td></tr><tr><td><br/></td><td><br/></td><td>- devtype = cdrom</td></tr><tr><td><br/></td><td><br/></td><td>- extra k=v arguments (cipher, key-size, key-file)</td></tr><tr><td>nic</td><td>s</td><td>add a virtual nic.</td></tr><tr><td><br/></td><td><br/></td><td>format: key=value,key=value,... (can be empty)</td></tr><tr><td><br/></td><td><br/></td><td>supported key: bridge, mac, id</td></tr><tr><td><br/></td><td><br/></td><td>examples:</td></tr><tr><td><br/></td><td><br/></td><td>\"nic = bridge=xen-br0,mac=ab:ef:fe:dc:ba:ab\"</td></tr><tr><td><br/></td><td><br/></td><td>\"nic = mac=ab:ef:fe:dc:ba:ab\"</td></tr><tr><td><br/></td><td><br/></td><td>\"nic = \"</td></tr><tr><td>pci</td><td>s</td><td>add a pci device.</td></tr><tr><td><br/></td><td><br/></td><td>format: devid,bind,domain:bus device.function</td></tr><tr><td>serial</td><td>s</td><td>redirect serial to device or network tcp:ip:port</td></tr><tr><td><br/></td><td><br/></td><td>ex: \"pty\" or \"tcp:1.2.3.4:1234\"</td></tr><tr><td>display</td><td>s</td><td>details the type of display available for the guest</td></tr><tr><td><br/></td><td><br/></td><td>format: :key[=value],key[=value],...</td></tr><tr><td><br/></td><td><br/></td><td>possible values:</td></tr><tr><td><br/></td><td><br/></td><td>- none</td></tr><tr><td><br/></td><td><br/></td><td>- vnc (keys allowed: use-port-unused, keymap, port)</td></tr><tr><td><br/></td><td><br/></td><td>- sdl</td></tr><tr><td><br/></td><td><br/></td><td>- intel</td></tr></tbody></table><p>(the following are just useful for pv)</p><table class=\"wrapped\"><thead><tr><th>key name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>cmdline</td><td>s</td><td>command line given to the kernel</td></tr><tr><td>initrd</td><td>s</td><td>specify the initrd use, leave empty for none</td></tr></tbody></table><p>(the following are just useful for hvm)</p><table class=\"wrapped\"><thead><tr><th>key name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>pae</td><td>b</td><td>specify that the guest is using PAE</td></tr><tr><td>acpi</td><td>b</td><td>specify that the guest is using ACPI</td></tr><tr><td>apic</td><td>b</td><td>specify that the guest is using APIC</td></tr><tr><td>nx</td><td>b</td><td>specify that the guest is using NX</td></tr><tr><td>smbios-pt</td><td>b</td><td>specify that the guest is using smbios pass-through</td></tr><tr><td>smbios-oem-type-pt</td><td>i</td><td>tables number to passthrough</td></tr><tr><td>acpi-pt</td><td>b</td><td>specify that the guest is using ACPI pass-through</td></tr><tr><td>diskinfo-pt</td><td>b</td><td>specify the guest is using SCSI diskinfo pass-through</td></tr><tr><td>boot</td><td>s</td><td>specify the qemu boot string</td></tr><tr><td>extra-hvm</td><td>k=v</td><td>specify extra arguments passthrough to qemu as -k v</td></tr><tr><td>power-management</td><td>i</td><td>specify the power management passthrough mode</td></tr><tr><td><br/></td><td><br/></td><td>- 1 : pass-through mode (limited scope)</td></tr><tr><td><br/></td><td><br/></td><td>- 2 : non pass-through mode (in doubt use this)</td></tr><tr><td>oem-features</td><td>i</td><td>specify whether or not to pass through oem features.</td></tr><tr><td><br/></td><td><br/></td><td>Note: At the moment any integer value can be passed</td></tr><tr><td><br/></td><td><br/></td><td>but this is likely to change in future especially if</td></tr><tr><td><br/></td><td><br/></td><td>we decide to pass through a subset of oem features</td></tr><tr><td><br/></td><td><br/></td><td>and let user configure that subset.</td></tr><tr><td>timer-mode</td><td>i</td><td>specify the timer mode used.</td></tr><tr><td>timeoffset</td><td>s</td><td>specify the time offset (i.e. timezone) used.</td></tr><tr><td>pci-msitranslate</td><td>i</td><td>specify whether to use MSI-INTx translation for guest.</td></tr><tr><td>pci-power-management</td><td>i</td><td>specify whether or not to enable Dx power management</td></tr><tr><td><br/></td><td><br/></td><td>for passthrough devices.</td></tr><tr><td>inject-sci</td><td>i</td><td>specify whether or not to inject SCIs like lid close,</td></tr><tr><td><br/></td><td><br/></td><td>power button press to guest. (Default: no injection)</td></tr></tbody></table><h1>Sending command to the monitor</h1><p>xenvm bind a unix socket to the uuid specified/generated You can easily send command to the monitor with xenvm-cmd using the simple syntax:</p><p>xenvm-cmd</p><p>The following command are supported:</p><ul><li>help</li><li>pause</li><li>unpause</li><li>destroy</li><li>start</li><li>suspend file=</li><li>suspend file= live=true</li><li>restore file=</li><li>checkpoint</li><li>shutdown</li><li>restart</li><li>quit (quit the monitor leaving the vm untouched)</li></ul><h1>Running with xen-unstable</h1><p>It's possible to run with xen-unstable directly, but you need the qemu-dm-wrapper script and xenguest binary in /usr/bin/. They are available in xenguest/xenguest and scripts/qemu-dm-wrapper in the toolstack.git repository.</p><p>And you need to replace your udev rules by the one available in scripts/xen-backend.rules and scripts/xen-frontend.rules and add the scripts/tap scripts/block scripts/block-front scripts/vif into /etc/xensource/scripts/</p><p>Also note that since xen-unstable doesn't have the dm-ready patch, hvm domain takes unfortunately a substantial time (around 20s.) to start.</p><h1>Example of config</h1><p>PV config with one LVM disk called 'test' and one VIF :</p><ac:structured-macro ac:macro-id=\"bb180181-3ec4-44db-a9d4-19c859dc93bd\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">text</ac:parameter><ac:plain-text-body><![CDATA[uuid = 00000000-0000-0000-0000-000000000001 \nhvm = false \nkernel = /boot/vmlinuz-2.6.18-xenU \ncmdline = root=/dev/sda1 ro \nmemory = 64 \ndisk = /dev/vg/test:phy:sda:w:disk \nvif =]]></ac:plain-text-body></ac:structured-macro><p>HVM config for installing a windows 2k3 from iso on a LVM disk called 'testhvm':</p><ac:structured-macro ac:macro-id=\"02936926-71a1-43b4-bbf8-3261f0b6a162\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">text</ac:parameter><ac:plain-text-body><![CDATA[uuid = 00000000-0000-0000-0000-000000000002 \nhvm = true \nmemory = 256 \ndisk = /dev/vg/testhvm:phy:hda:w:disk \ndisk = /var/opt/xen/iso_import/w2k3eesp2.iso:file:hdd:r:cdrom \nboot = dc \npae = true\nacpi = true \napic = true ]]></ac:plain-text-body></ac:structured-macro><p class=\"auto-cursor-target\"><br/></p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}