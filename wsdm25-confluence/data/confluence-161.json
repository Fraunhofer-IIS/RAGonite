{
    "id": "confluence-161",
    "title": "Windows XPDM PV Display Driver and Miniport",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/15368300/Windows+XPDM+PV+Display+Driver+and+Miniport",
    "content": "<p>Owned by Ross Philipson\nLast updated: Oct 08, 2015 by Ross Philipson\n\n</p><p><strong>Implementing an XPDM Display Driver for the new Display Handler.</strong></p><p><strong>Refer to:</strong> RFC Display Handler Architecture.pdf</p><p><strong>Purpose:</strong> Information dump for notes while writing the new Windows XPDM PV Display driver. Eventually this will evolve into a full-blown reference/design document for the driver.</p><hr/><p><strong>Questions and Assumptions about the modified XPDM display driver and miniport</strong></p><div><strong><br/></strong><p><strong>Desktop: A desktop is a collection of extended displays</strong></p><p>How many desktops can there be? If I have 2 running guests, can I simultaneously display both guests (one on each monitor)? Description of Full Screen Compositor indicates \"no\"? ANSWER: Pinned display: Always attached to a VM, even after switching away from that VM Shared display: physical display moves back and forth between VMs during hot switching. BUT as far as the VM is concerned, the displays are always attached, even after a hot switch.</p><p><strong>However the VM is not guaranteed to be the same resolution as the displays (i.e. the display handler might reduce the size of the VM to make room for banner markings).</strong></p><p>I assume that this happens behind the VM's back. That is, the Display Handler will tell the VM driver the USABLE size of the display, not necessarily the ACTUAL size of the display. For example, if the display is physically 1920x1080, but the Display Handler wishes to reserve a 100 pixel tall banner at the top, the Display Handler will report back to the VM driver that the display is 1820x1080. ANSWER: Confirmed correct. VM driver can select a different resolution than Display Handler requests. If VM resolution doesn't match Display Handler resolution, Display Handler will scale. This should be avoided.</p><p><strong>If the user selects “cloned”, all of the monitors will belong to the same display, and the desktop will consist of only one display.</strong></p><p>Does this happen at the VM driver level, or Display Handler level? For a cloned display, with the VM driver present 2 monitors to the OS? Present 1 monitor to the OS, but manage the second behind the OS's back? Or present and manage a single monitor and let the Display Handler worry about how it gets cloned? ANSWER: All happens in the display handler. VM driver never needs to clone a display.</p><p><strong>The proposed Display Handler would contain a dumb-buffer renderer</strong></p><p>I assume from this, that hooking and implementing DDI, DDRAW and D3D accelerations in the VM driver is not planned at this time. ANSWER: Correct. BUT there will be HW cursor support.</p><p><strong>No support is planned for changes in monitor orientation in this version of the Display Handler.</strong></p><p>I assume from this that supporting rotated framebuffers is not planned at this time. ANSWER: correct.</p><p><strong>The Display Handler will be able to support more than one GPU, but initial support for the UIVM is one GPU at a time. The UIVM will provide a means to select which graphics device to use.</strong></p><p>I'm assuming the above can be ignored for now. Does \"graphics device\" here mean GPU or Display Controller? Since there is no acceleration, the number of GPUs is irrelevant, and could even be zero. The management of the display controllers should fall to the new Display Handler, shouldn't it? I don't anticipate the VM driver needing to \"Select which graphics device to use\" until it implements accelerated drawing. ANSWER: Always hidden from the VM driver, even with acceleration.</p><p><strong>The Display Handler however has to send a lot of information at very high frequencies. Using event based communications would destroy the overall performance of the system.</strong></p><p>For an unaccelerated VM display driver, there shouldn't be any need for high frequency communication between the VM driver and the Display Handler, should there? Again, I don't see this feature being useful until accelerated drawing is implemented. ANSWER: Dirty rectangles must be sent. To implement this, we create a \"channels\" for the framebuffer, event channel, and dirty rectangle implementation.</p><p><strong>This mechanism provides a simple API (socket-style, address / port connections) for creating shared memory. This shared memory can be used for simple framebuffer data</strong></p><p>Is it the intent then, during VM driver initialization, that this shared memory would be used for the framebuffer, instead of the standard video memory typically exposed through the QEMU VGA device? That is, instead of the VM driver querying the bios for the framebuffer location and size, it would allocate framebuffer memory from the Display Handler through this new API? I am assuming the answer to this is \"yes\". ANSWER: yes. We will not communicate with the QEMU device</p><p><strong>Provide simple API for setting up shared memory with the guest. This API uses an address/port style connection.</strong></p><p>VM display driver will use this mechanism to allocate and map video memory from the Display Handler, to Windows. ANSWER: yes.</p><p><strong>Provide simple API for setting up ring buffer communications on-top of shared memory provided by the shared memory API.</strong></p><p>Irrelevant for now, as there is no accelerated drawing, so no need for a ring buffer. Unless the intent is for communication to the display controller will go through a ring buffer? Assuming the answer is \"no\". ANSWER: yes, HW cursor and Dirty Rectangle information go in the ring buffer. Resolution control information also.</p><p><strong>In order to support the Display Handler, a new Input Server will also need to be added.</strong></p><p>I am assuming that the Input Server is pretty much irrelevant to the VM display driver. ANSWER: correct.</p><p><strong>QEMU is needed to not only provide basic OS support, but also provides video support for the initial configuration of the VM, as well as the boot process of the VM when PV drivers cannot be used.</strong></p><p>I assume that once the VM driver takes over, QEMU moves out of the picture, and the VM interacts with the Display Manager instead of the VESA BIOS. ANSWER: correct.</p><p><strong>Udev support will be built into Disman. This will provide hot-plug &amp; hot-unplug support.</strong></p><p>This is an event that comes from the Display Manager, and must be communicated up to the XPDM driver, and on to Windows? ANSWER: yes.</p><p><strong>The renderer is the entity that physically talks to the hardware.</strong></p><p>The VM driver will not talk directly to the renderer. ANSWER: correct.</p><p><strong>When a monitor is added and the “mode” is “extended”...</strong></p><p>This is an event that comes from Display Manager and needs to be communicated back to the VM driver, and to Windows? ANSWER: Correct.</p><p><strong>If the user changes the resolution of a display, and the display overlaps with other displays...</strong></p><p>What is the mechanism for triggering this event? Typically display resolution changes come from Windows, and Windows tells the driver. Is this \"change-resolution\" command coming from the Display Manager? ANSWER: IT comes from the Display Manager. We have to force Windows to change.</p><p><strong>[Dumb Buffer Renderer] Renders any overlays that are drawn on the desktop</strong></p><p>Do we intend to implement overlays in the Windows driver at this time? ANSWER: No.</p><p><strong>If the guest has more displays than the host,</strong></p><p>How would this situation come about? ANSWER: user unplugs a monitor. Display Handler notifies the driver, but the driver can't respond.</p><p><strong>If the guest has only one monitor, and the host has many, the guest will be cloned to the other host monitors</strong></p><p>This happens outside of the VM display driver, right? Nothing to do in the driver, right? ANSWER: Correct.</p><hr/><p><strong>Design Considerations</strong></p><p><strong>Init</strong></p><ul><li>\"Device\" detection. Discover the existance of the Display Handler<ul><li>Detection failure? What do we do if the new Display Handler can't be contacted?<ul><li>Assume fail to load. Windows should fall back to the VGA driver.</li></ul></li></ul></li><li>Create communications channel</li><li>Allocate shared memory</li><li>Set up Control Channel</li><li>Share Control with display-dll</li><li>Create communications event</li><li>Create thread to monitor messages from display handler<ul><li>PsCreateSystemThread()</li></ul></li><li>Mechanism to signal Windows when we need its attention<ul><li>Generate some kind of SW Interrupt and catch it in HwInterrupt()?</li></ul></li><li>Discover number of displays from Display Handler, report to Windows.<ul><li>dh_display_list_packet</li><li>VideoPortCreateSecondaryDisplay for additional displays</li><li>IOCTL_VIDEO_MAP_VIDEO_MEMORY</li><li>IOCTL_VIDEO_SET_CURRENT_MODE</li><li>IOCTL_VIDEO_RESET_DEVICE</li><li>IOCTL_VIDEO_SHARE_VIDEO_MEMORY</li><li>IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION</li><li>IOCTL_VIDEO_GET_CHILD_STATE</li><li>IOCTL_VIDEO_SWITCH_DUALVIEW<ul><li>Triggered by ChangeDisplaySettings ()<ul><li>This has to come from user-mode? Options:</li><li>Catch it in the minport, signal the display driver, which signals a user-mode app, which forces a ChangeDisplaySettings() call</li><li>Set it up in the miniport, but catch it in the display driver (since technically it is running in kernel space), pass that up to a user-mode app, which forces a ChangeDisplaySettings() call. Use the miniport to set up a shared-memory area that the user mode app can read directly. When it sees the flag, it forces a ChangeDisplaySettings() call.</li><li>Is there any way to do this WITHOUT a user-mode helper app?</li><li>Investigate solutions from other sources.</li></ul></li></ul></li><li>dh_add_display_packet</li><li>dh_set_display_packet</li><li>Per-Display init<ul><li>Framebuffer Channel</li><li>HW Cursor Channel</li><li>Dirty Rectangle Channel</li><li>Event Channel Channel</li></ul></li><li>Create communications mechanism between miniport and display driver for the above channels</li><li>dh_display_advertised_list_packet</li><li>local address-to-physical address conversion in the display driver</li></ul></li></ul><p><strong>Modeset</strong></p><ul><li>Request modes from Display Handler.</li><li>Present to Windows.</li><li>Allow Windows to pick which in wants to use</li><li>Instruct Display Handler to set this mode<ul><li>dh_set_display_packet</li></ul></li><li>Guest display removal<ul><li>dh_display_no_longer_available</li></ul></li><li>Hot-unplug<ul><li>dh_remove_display_packet</li></ul></li></ul><p><strong>Display Handler Re-init</strong></p><ul><li>Catch this in the miniport</li><li>dh_remove_display_packet OR complete disconnection from Display Handler<ul><li>Poll Display Handler until it comes alive again?</li></ul></li><li>Re-init miniport.</li><li>Send message to our system tray app to re-paint or re-modeset</li></ul><p><strong>Surface Creation</strong></p><ul><li>Surfaces must be engine managed, to force Windows to notify the driver for every change to the frame buffer.</li><li>Surface formats must be in standard windows bitmap format, so drawing operations can be punted back to Windows.</li><li>Current XenVesa driver needs this implemented. It would be better to use a different starting driver, which may already have device managed surfaces, HW cursor, and dirty rectangles already implemented.</li><li>Do we need to do any coordinate-transformation between our surfaces, and the surfaces seen by Display Manager?</li></ul><p><strong>Acceleration</strong></p><ul><li>No acceleration planned at this time.</li><li>Overlay is relatively easy to support.</li><li>Full direct-draw support will be difficult with respect to dirty rectangles<ul><li>Surface locking allows applications to draw directly to video memory</li><li>Could notify Display Manager when surface is locked and unlocked, allowing it to do scraping during the locked phase.</li></ul></li></ul><p><strong>Dirty Rectangles</strong></p><ul><li>Mostly written in other drivers.</li><li>Insert dirty rectangle information in Ring/Message buffer and signal Display Manager.</li></ul><p><strong>HW Cursor</strong></p><ul><li>Mostly written in other drivers.</li><li>Create Cursor<ul><li>PACKET_TYPE_EVENT_UPDATE_CURSOR</li></ul></li><li>Move Cursor<ul><li>PACKET_TYPE_EVENT_MOVE_CURSOR</li></ul></li></ul><p><strong>Asynchronous Events</strong></p><ul><li>Monitor hotplug/unplug</li><li>Resolution change</li><li>Pass up to a user mode app (system tray app), which forces a display resolution change.<ul><li>Investigate other solutions that avoid the system tray app.</li></ul></li></ul><p><strong>General</strong></p><ul><li>XenVesa is not a good base.</li><li>Starting driver might better be something based on the IGX virtual driver, which already has surface management, HW Cursor, and dirty rectangle support built in.</li></ul><p><strong><br/></strong></p></div>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}