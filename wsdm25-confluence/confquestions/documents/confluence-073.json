{
    "id": "confluence-073",
    "title": "PCI-DM-HELPER and IGD Passthrough",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/29851668/PCI-DM-HELPER+and+IGD+Passthrough",
    "content": "<p>Owned by Eric Chanudet\nLast updated: Oct 06, 2016 by Ross Philipson\n\n</p><ac:structured-macro ac:macro-id=\"e51264a6-6cf2-48c6-ab9c-c4e2c07469d9\" ac:name=\"info\" ac:schema-version=\"1\"><ac:parameter ac:name=\"icon\">None</ac:parameter><ac:rich-text-body><p><ac:image ac:width=\"80\"><ri:attachment ri:filename=\"cc-by.png\"></ri:attachment></ac:image></p><p>Copyright 2016 by Assured Information Security, Inc. Created by Eric Chanudet &lt;chanudete@<a href=\"http://ainfosec.com\">ainfosec.com</a>&gt;. This work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy of this license, visit <a class=\"external-link\" href=\"http://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\">http://creativecommons.org/licenses/by/4.0/</a>.<br/> Contributions by Ross Philipson &lt;philipsonr@<a href=\"http://ainfosec.com\">ainfosec.com</a>&gt;</p></ac:rich-text-body></ac:structured-macro><p><ac:structured-macro ac:macro-id=\"ece0cb05-71ee-4975-b6c0-066c9be44d49\" ac:name=\"toc\" ac:schema-version=\"1\"></ac:structured-macro></p><h1>PCI-DM-HELPER</h1><p>Pci-dm-helper is a helper started through the xenvm toolstack to receive request from a stub-domain to access a passed-through PCI device config. space. It will also give the stubdomain the required IO permissions depending on the device.</p><p>This project is deprecated in 5.0.0 and later version of OpenXT.</p><h2>Dependencies</h2><p>libpciaccess</p><p>v4v (libv4v)</p><p>xenctrl (libxc)</p><p>xenstore (libxenstore)</p><p>IOEMU support (patch stubdoms, <a href=\"https://github.com/OpenXT-Extras/ioemu-pq/blob/master/master/stubdoms\" style=\"line-height: 1.42857;\">https://github.com/OpenXT-Extras/ioemu-pq/blob/master/master/stubdoms</a>)</p><h2>Use and Context</h2><h3>Toolstack relationship</h3><p>The toolstack is responsible for starting this helper when required. As this helper is listening on the v4v-socker through which RPC will be sent by the device model, it must be ready before the stub-domain, as re-connection is not mandatory in the device-model. Currently started in dm.ml.</p><h3>Usage</h3><pre>pci-dm-helper guest-domid stub-domain-id\n\tguest-domid\tdomid of the guest\n\tstub-domain-id\tdomid of the stub-domain handling the device-model for guest-domid\n</pre><h3>Features</h3><p>pci-dm-helper will give appropriate permissions to the stub-domain to access relevant resources for the device passed-through and handle request to access its config. space.</p><h3>Access permission</h3><p>Permissions are attributed to the stub-domain by reading pci-backend/frontend Xenstore entries:</p><ul><li>/local/domain/0/backend/pci/&lt;stubdom-id&gt;/0/num_devs</li><li>/local/domain/0/backend/pci/&lt;stubdom-id&gt;/0/dev-&lt;devid&gt; pci-dm-helper</li></ul><p>will retrieve each device BDF and assign permissions depending on the device: - Not a graphic card (pci-device-class != 0x300), no permission - Any graphic card, 0x3b0-0x3cf ports and 0xa0000-0xbffff io-memory access - Intel Graphic Device (pci-vendor-id == 0x8086), 0x3c0-0x3df ports; if the device exposes an op-region (address at pci config. space 0xfc), stub-domain will be given permission to access as well, - ATI graphic card (pci-vendor-id == 0x1002), 0x3c0-0x3c2 and 0x3c4-0x3df ports.</p><h3>Remote PCI config. space access</h3><p>pci-dm-helper will open a listening socket over v4v on port 5559 and wait for incomming connection. Once connection is established, the remote client will be able to send packet structures to request read/write to the config. space of a device. Such packets are formated as:</p><pre>struct remotepci_req {\n    unsigned read:1;\n    unsigned write:1;\n    unsigned align:6;\n    u_int16_t domain;\n    u_int8_t bus, dev, func;\n    u_int16_t offset;\n    union {\n        u_int32_t len;\n        u_int32_t v;\n    };\n} __attribute__((packed));</pre><h3>PCI pass-through: VGAbios copy</h3><p>Guest's might expect the VGAbios from a pass-through card to be mapped at 0xc0000 (e.g Intel Graphic Card). This is not handled by hvmloader; it will only load the default built-in VGABios. Pci-dm-helper will copy the VGAbios from dom0 at 0xc0000 to the guest 0xc0000 (using xc_map_foreign_range()).</p><h1>IGD Passthrough</h1><p>This section is incomplete. It is mainly a dump of what can be remembered about the kinds of things that had to be done to make IGD passthrough work.</p><ul><li>The guest drivers had to have access to the VGA IO ports at 0x3C0 (see <a href=\"http://wiki.osdev.org/VGA_Hardware#Port_0x3C0\">http://wiki.osdev.org/VGA_Hardware#Port_0x3C0</a>).  Pci-dm-helper make it available to guests using xc_domain_ioport_permission.</li><li>The guest drivers had to have access to the IGD Opregion MMIO region. The base address is fetched from the IGD device's config space. Pci-dm-helper used to fetch the location and make it available to guests using xc_domain_iomem_permission.</li><li>The actual VGABios of the IGD card had to be loaded into the guest at the legacy OROM slot 0xC0000. As noted above, pci-dm-helper did this.</li><li>The guest drivers got a filtered list of IGD device capabilities. This was done in IOEMU (IIRC?). The functionality was probably dropped in the QEMU 1.4 uprev.</li><li>The guest drivers needed access to the IGD device and platform's vendor capabilities stored as a vendor specific capability on the host bridge device (00:0.0). This was done in IOEMU pass-through code.  The functionality dropped in the QEMU 1.4 uprev.</li><li>The guest drivers expected to see a legacy ISA bridge surfaced at 00:1f.0 on the PCI bus. A dummy device was surfaced by IOEMU. The functionality dropped in the QEMU 1.4 uprev.</li><li>The QEMU support patch 0007-pci-reserve-igd-slot.patch is gone.</li></ul><p>Several versions of IGD passthrough were posted for inclusion in Xen/QEMU. If IGD passthrough were brought back, it should be based on this work.</p><p>Better yet, with a proper graphics stack, GVT-g and XenGT would be the way to go.</p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}