{
    "id": "confluence-037",
    "title": "Argo : Hypervisor-Mediated data eXchange : Development",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/737345538/Argo+:+Hypervisor-Mediated+data+eXchange+:+Development",
    "content": "<p>Owned by Christopher Clark\nLast updated: Jan 13, 2021 by Christopher Clark\n\n</p><p>Items to address in Argo development – several items listed are described in more detail further down this page.</p><p>LONG-RUNNING-DOMAIN-SHUTDOWN-WORK)<br/>When a domain is shut down, the hypervisor runs a function to remove all the hypervisor state that is associated with the domain. It needs further development because it can be a long-running function and it should not block the hypervisor from making progress on other work while it is performed. Investigate batching the work with periodic yields as needed.</p><p>SENDER-DOMAIN-CONTEXT)  : OXT-1503<br/>Hypervisor to provide context about the domain sending a message to the message recipient. Context will include the sender's XSM sid when operating on XSM-enabled Xen systems.</p><p>- Value: guest software can trust and reason about security context of message source<br/>- Value: supports implementation of strong access control</p><p>NAME-SERVICE)<br/>- design input: a simple reference implementation exists in the uXen v4v driver<br/>- Value: supports use/port of the v4v Linux device driver to Argo<br/>- Value: supports communication between endpoints at different layers of nested virtualization<br/>- Value: supports reconnection of device drivers across domain reboot<br/>- Value: towards enabling PV drivers and other connections without XenStore -&gt; Value: encourages adoption of Argo (Xen Community members have expressed interest)</p><p>LINUX-DRIVER) : <a href=\"https://openxt.atlassian.net/browse/OXT-1473\">OXT-1473</a><br/>A modern Linux device driver implementation suitable for submission to and inclusion in the upstream Linux kernel tree.</p><p>There is a separate wiki page for <ac:link><ri:page ri:content-title=\"New Linux Driver for Argo\" ri:version-at-save=\"22\"></ri:page><ac:plain-text-link-body><![CDATA[Linux Argo Driver]]></ac:plain-text-link-body></ac:link> development.</p><p>- Value: Higher-quality software implementation for OpenXT; easier to review for security properties and maintain.<br/>- Value: Supports adoption of Argo beyond OpenXT. eg. can satisfy external code review.</p><p>REMOTE-CONTEXT)<br/>Communication of sender process context between domains.<br/>In the guest-to-guest protocol within the Linux Argo device driver, convey a process identifier and SELinux security context of the source process to the receiver domain to enable access control checks to be performed there. To be implemented in LINUX-DRIVER.<br/>Proposed by Stephen Smalley at the OpenXT Summit 2016:<br/><a href=\"https://github.com/OpenXT/docs/raw/master/presentations/2016-06-07-openxt-summit/14%20-%20Smalley%20-%20Access%20Control.pdf\">https://github.com/OpenXT/docs/raw/master/presentations/2016-06-07-openxt-summit/14%20-%20Smalley%20-%20Access%20Control.pdf</a></p><p>CONNECTION-STATE)<br/>Enforce and track pairing of the rings used for bidirectional communication endpoints.<br/>Bidirectional exchange of messages between domains is essential to most use cases for Argo. In the common scenario, a service is registered on a well-known port, while clients connect from dynamically-allocated (ie. temporally assigned) ports. Tracking endpoint connection state within the hypervisor is necessary to enable access control rules to apply narrowly to bidirectional connections instead of relying on broad, non-specific inverse rules as seen with the viptables.</p><p>- Value: A pre-requisite for strong Access Control (Argo firewall).</p><p>ACCESS-CONTROL)<br/>Run-time configurable mandatory access control over messages. ie. A replacement for the OpenXT viptables/v4vtables \"firewall\".<br/>Acts upon SENDER-DOMAIN-CONTEXT and REMOTE-CONTEXT data and depends upon CONNECTION-STATE.</p><p>- Implementation of a new, granular firewall with Connection State awareness.<br/>- Hypervisor, kernel and userspace components to this.<br/>- Value: Enables integration of firewall into upstream Xen.<br/>- Value: Hypervisor-enforced granular control over accessibility of communication channels. A strong differentiator of Argo vs. other interdomain communication systems. Supports effort for Argo to attain security support in Xen, and for Argo being enabled by default on Xen systems.</p><p>WILDCARD-PROGRESS)<br/>Wildcard (any-sender) rings: ensuring that all senders are able to make forward-progress with message transmission to the receiver.<br/>ie. Preventing DoS of a sender's access to the ring by any another sender.</p><p>Senders register resources for option to buffer on send and potentially throttle.<br/>Firewall likely to be helpful in practice by enabling constraints on classes of authorized sender domains.<br/>See Hyper-V's primitives for inter-VM communication: use of transmit slots.<br/>- Value: Improves resiliency of Argo services (eg. in multi-tenant systems), which supports effort for Argo to attain security support in Xen, and for Argo being enabled by default on Xen systems.</p><p>SHUTTER-RINGS)<br/>Improving confidentiality of transmitted data to host memory read attacks.<br/>Option to replace the permanently-resident ring mappings with transient mappings created and destroyed as messages are sent on specific rings.<br/>Policy controls for use to be determined.</p><p>- Value: improves confidentiality of data and resilience to speculative execution data read attacks.</p><p>WILDCARD-SPACE-WAKEUPS)<br/>Investigate improvement to the efficiency of ring notifications for space availabilty in wildcard rings: avoid the stampeding herd.</p><p>- Value: potential for improvement in scalability, performance or performance isolation.</p><p>NOTIFY-RING)<br/>Investigate improvement to the efficiency of notifications for message delivery: option to provide receiver with more than a single interrupt bit when a message is delivered: write the destination ring id into a<br/>dedicated notification ring registered by the receiver.</p><p>- Value: Performance improvement in the guest device driver; improved scalability, especially for server VMs with many rings.<br/>- Challenge: Increases complexity of implementation in the hypervisor. Could potentially be addressed via making it an independent KCONFIG option.</p><p>CROSS-NESTING-COMMS)<br/>Investigate changes to the Argo guest interface necessary to facilitate efficient communication between guests at different levels of nested virtualization. Determine what cooperation, if any, is necessary or beneficial between the nested hypervisors.</p><p>- eg. Should enable communication between uXen and Xen guests on the same system.<br/>- Will need a smart way to enable and control/restrict this.<br/>- Value: granular Mandatory Access Control enforcement over multi-level communication paths.</p><p>ARGO-FOR-UXEN)</p><p>- Value: same interfaces on both hypervisors increases scale of deployment options for software and policies developed against the interfaces, so development of workloads is more attractive.<br/>- Value: enables close integration of uXen and microVMs on a Xen-based system (eg. OpenXT)<br/>- Value: potential for guest compatibility between uXen and Xen systems.<br/>- Value: Argo is more widely deployable via uXen systems.<br/>- Value: benefits of Argo made available to uXen systems.</p><p>Further items:</p><p>* OXT-1677: Documentation of Argo<br/>- hypervisor developer guide<br/>- guest software guide<br/>- userspace admin guide<br/>- Value: enables faster and wider adoption of Argo.</p><p>* OXT-1683: Test coverage of Argo<br/>- Value: protects Argo against regressions as software develops.<br/>- Value: enables reproduction of behaviour for investigation, inspection.</p><p>* OXT-1691: Use Linux sock_type values for communicating protocol between endpoints<br/>- ie. datagram vs. stream<br/>- Value: a more standard implementation, and requested by the OpenXT community.</p><p>* OXT-1660: Remove the compat ioctl from the Linux Argo device driver<br/>- this is an unneeded remnant originally from v4v<br/>- Value: increased confidence in implementation; simplifies sanity checking user-supplied values.</p><p>* Implement network and block PV drivers for Xen using Argo<br/>- Value: enables dropping XenStore and the grant tables from the hypervisor and in-guest software<br/>- Value: encourages wide deployment and so sustained testing of Argo<br/>-&gt; Value: wider adoption enables more resources for eg. performance profiling and tuning<br/>- Value: may enable PV drivers in dom0less configurations</p><p>* Self-protection via access control<br/>- investigate option for guests to request firewalling of themselves<br/>- Value: could enable simple self-hardening</p><p>* Research: Argo support for time-sensitive message transport (eg. time sensitive networking)<br/>- Scheduler intergration likely essential<br/>- Value: Time Sensitive Networking is increasing in importance -- eg. may soon be required by clients in order to access secure cloud systems -- yet hard to support on virtualized systems.</p><p>* Research: Integration with memory encryption technologies<br/>- Value: May be necessary for compatibility when in use by guests / platforms.</p><p>* Research: Accelerated transport options leveraging available hardware<br/>- Value: Potential for performance and scalability improvement; could broaden Argo's use cases.</p><p>* Research: Asynchronous message send primitive<br/>- Value: Potential for performance and scalability improvement; could broaden Argo's use cases.</p><p>* Research: Can Argo assist with support for Hyper-V enlightenments?<br/>- Value: Attractive for XenServer, widens Argo's use cases, improves guest experience.</p><p><br/></p><p>HYPERVISOR-AGNOSTIC HYPERVISOR INTERFACE)</p><p><a href=\"https://openxt.atlassian.net/wiki/spaces/DC/pages/1696169985/VirtIO-Argo+Development+Phase+1#Project:-Hypervisor-agnostic-Hypervisor-Interface\">See description on the VirtIO-Argo page.</a></p><p>INTERRUPT DELIVERY WITHOUT EVENT CHANNELS)</p><p><a href=\"https://openxt.atlassian.net/wiki/spaces/DC/pages/1696169985/VirtIO-Argo+Development+Phase+1#Project:-Argo-interrupt-delivery-via-native-mechanism\">See description on the VirtIO-Argo page.</a></p><p><br/></p><hr/><h2>Additional detail on some items follows</h2><p><br/></p><hr/><p>SENDER-DOMAIN-CONTEXT</p><p>The hypervisor will provide context data about the domain that sent an Argo message to the receiving domain.</p><p>The message context currently provided with each Argo message is:<br/>* The sender's domain ID, provided by the hypervisor.<br/>* For partner rings: the hypervisor will ensure that the sending domain is the same domain as when the receiver registered the ring.<br/>(ie. a more recent domain with the same domain ID cannot spoof the original.)<br/>* The sender's Argo port, provided by the sender.<br/>* A \"message type\" value, provided by the sender.</p><p>The message header will be revised to add additional data:<br/>* On XSM-enabled systems: the 32-bit XSM sid of the sender domain.</p><p>This change will require reducing the size of the currently-32-bit message_type field.</p><p><br/></p><hr/><p>EXTENDED-SENDER-DOMAIN-CONTEXT</p><p>This extended data is for consideration - no firm decision made on this:</p><p>Adds additional data to the sender domain context:</p><p>* An 8-bit set of binary sender context flags, to include bits for:<br/>+ Sender domain is privileged.<br/>- this is usually dom0, but may differ on disaggregated systems<br/>+ Sender domain is a device model stubdomain of the receipient domain.<br/>- specifically: src_d has priv over dst_d<br/>+ Receipient is a device model stubdomain of the sender domain.<br/>- specifically: dst_d has priv over src_d<br/>+ The remaining bits are reserved.</p><p><br/></p><hr/><p>CONNECTION-STATE</p><p>Enforce and track the pair relationship between communicating endpoints, to provide foundation for support of fine-grained access control.</p><p>To consider: connection state tracking could be made dependent on some indicator the <em>protocol</em> </p><p>Changes to ring registration:</p><ul><li>The domain registering a ring must declare the ring, and hence the endpoint, to be one of these types:<ul><li>Client ring: for receiving messages from an entity that has registered a <em>specified remote ring</em>: <code>&lt;dst_d, dst_aport&gt;</code><br/>which must be indicated when the new client ring is registered and must already exist.<br/><br/><ul><li>The declared destination state is recorded in the hypervisor's internal ring state.</li><li>Client rings cannot be registered as wildcard rings.</li></ul></li><li>Server ring: for receiving messages from entities that may register client rings later.</li></ul></li></ul><p>=&gt; to investigate: impact of wildcard rings and more-specific matching rings that are registered later. May need to block those being registered if a wildcard ring has already been registered.</p><p>Changes to the message send operation:</p><ul><li>Enforce that one end of the transmission is a Client ring and the other a Server ring.</li><li>Add verification that the claimed source ring for a message exists before allowing the message to be sent.<ul><li>A domain's own ring must therefore be registered before sendv will accept it as a source address of a message.</li></ul></li><li>If the ring for the sending domain's message source address is a client ring, require that the message's destination matches the client ring's destination specified when the client ring was registered.<ul><li>Refuse the message transmission if not.</li></ul></li><li>If the ring for the receiving domain's message destination address is a client ring, require that the message's source matches the client ring's destination specified when the client ring was registered.<ul><li>Refuse the message transmission if not.</li></ul></li></ul><p><br/></p><p>Note that the above changes are significant and require changes to the access patterns to hypervisor-internal ring state and consequently there is likely to be impact on the fine-grained locking discipline within the current implementation. Maintaining performance isolation between domains to prevent DoS potential will require attention.</p><p><br/></p><hr/><p>ACCESS-CONTROL</p><p>Argo implements XSM controls over the hypercall operations. These are static, defined in the host XSM policy, and enable expression of coarse granularity rules over (src domain -&gt; dst domain) connectivity. An additional mechanism that enforces finer-grained and dynamic access control rules over the connectivity between guests Argo messages is required.</p><ul><li>Finer-grained: able to validate and act upon additional fields beyond just the domain's XSM sid.</li><li>Dynamic: rules are added and removed at runtime, typically by the toolstack, as domains transition through their lifecycles.</li></ul><p>Support for both static and dynamic rules is desirable:</p><ul><li>Static Rules: A set of fixed firewall rules that are always enforced.</li><li><p>Dynamic Rules: These can be added and removed at runtime and are able to both narrow and widen the set of allowed communication paths, within constraints set by the Static Rules.</p></li></ul><p>Static Rules should be provided at host boot, measured, and enforced at all times throughout the host lifecycle. The DomB proposal may be appropriate for an implementation of rule programming during system launch, such that the control domain can be confined. A mechanism is required for ensuring that the programmed Static Rules are irrevocable until host shutdown.</p><p>To ensure that Static Rules cannot be circumvented, the programmed rules must support expression for whether they may be narrowed or widened by later rules. The intention is that Static Rules will be non-circumventable (eg. by the control domain) aside from performing modification to the materials that are measured during boot.</p><p><br/>* Self-protection</p><p>Domains should be able to supply their own rules to narrow communication allowed to them and so enable self-protection. These rules should support the option for being irrevocable by the domain itself for the lifetime of the domain.</p><p>* Policy controls over dynamic rule operations</p><p>The access control system has the following basic operations:</p><ul><li>Add rule<br/>- Introduces a new access control rule at the specified position.</li><li>Delete rule<br/>- Removes a specified access control rule.</li><li>List the active rules<br/>- Retrieves the list of current access control rules.</li></ul><p>XSM policy needs to be able to express which domains are authorized to view or perform modifications to the access control rules, with context about which domains are affected by the specific rule being modified or listed.</p><p>To consider/investigate:</p><p>+ What granularity is correct for the policy controls over the rules?<br/>eg. viptables/v4vtables has the basic constraint: only the privileged domain can perform the rule operations. This prevents domains from being able to self-protect.</p><p>+ Is it important to be able to enable (ie. in a specific configuration) that a domain is able to list all the access control rules that are applied to it, but is not able to list those applied to other domains?</p><p>* Filter terms</p><p>Support needs to be implemented for expressing rules that inspect and match on:<br/>+ source domain id<br/>+ destination domain id<br/>+ source Argo port<br/>+ destination Argo port<br/>+ source domain XSM sid<br/>+ source domain is control domain<br/>+ source domain is stub domain of the other communication endpoint<br/>+ destination domain is stub domain of the other communication endpoint<br/>+ message type<br/>+ bi-directional : rule applies to messages (typically replies) sent in the opposite direction too</p><p>Implementation of CONNECTION-STATE is required to enable rules for allowing bi-directional connections (the common case) and avoid requiring generalized, very permissive, \"inverse rules\".</p><p>To investigate: support for rules that inspect and match on guest header fields:<br/>+ process identifier<br/>+ process SELinux security context</p><p>* Interface of the Argo Notify op</p><p>The notify op enables a domain to query the state of another domain's ring, and request notification when space becomes available.</p><p>To investigate: the query operation should specify which source port the query is on behalf of, and return an error if communication from that source to the destination being queried is disallowed. This is to assist correct behaviour within the querying domain.</p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}