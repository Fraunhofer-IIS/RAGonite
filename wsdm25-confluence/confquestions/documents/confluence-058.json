{
    "id": "confluence-058",
    "title": "Linux VM Kernel Debugging",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/14843958/Linux+VM+Kernel+Debugging",
    "content": "<p>Owned by Ross Philipson\nLast updated: Sep 24, 2018 by Tim Konick\n\n</p><p class=\"auto-cursor-target\"><br/></p><ac:structured-macro ac:macro-id=\"c268379a-2f99-4e21-ac2f-54d9fb2fb966\" ac:name=\"info\" ac:schema-version=\"1\"><ac:parameter ac:name=\"icon\">None</ac:parameter><ac:rich-text-body><p><ac:image ac:width=\"80\"><ri:attachment ri:filename=\"cc-by.png\" ri:version-at-save=\"1\"><ri:page ri:content-title=\"Documentation Guidelines\" ri:space-key=\"OD\" ri:version-at-save=\"12\"></ri:page></ri:attachment></ac:image></p><p>Copyright 2015 by Assured Information Security, Inc. Created by Ross Philipson &lt;philipsonr@ainfosec.com&gt;. This work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy of this license, visit <a class=\"external-link\" href=\"http://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\">http://creativecommons.org/licenses/by/4.0/</a>.</p></ac:rich-text-body></ac:structured-macro><p><ac:structured-macro ac:macro-id=\"4b8f7fc4-4f32-48aa-94e7-640a9dabbcf6\" ac:name=\"toc\" ac:schema-version=\"1\"></ac:structured-macro></p><h2>Introduction</h2><p>These are some handy steps for doing Linux live kernel debugging on the OpenXT platform. OpenXT makes this readily doable by using serial over IP within QEMU to connect the remote debugger GDB to the kernel debugger KGDB. Of course everyone has their favorite distro but for this we will stick to just one – Debian. Most of the steps should be the same with other flavors aside from the package management bits and specifics of rebuilding the kernel sources.</p><h2>Beforehand</h2><p>Here are some things to setup up first and to keep in mind while going through this:</p><ul><li>This is based on using Debian Wheezy HVMs. That means apt package manager and .deb package files.</li><li>Throughout this guide:<ul><li><strong>target</strong> is the VM that is being kernel debugged</li><li><strong>host</strong> is the debugger, the VM where GDB is remotely connecting to the <strong>target</strong>.</li></ul></li><li>For simplicity, it is assumed both the host and target are the same OS or distro. The paths and users on both are the same. Also password-less SSH login and sudo setup are assumed.</li><li>A basic set of development tools is needed on the target to build the kernel - <code>sudo apt-get install build-essential</code> should be sufficient (note sometimes <code>dpkg-dev</code> or <code>ncurses-dev</code> need to be installed manually).</li></ul><p>So to get started, install OpenXT and create 2 Debian Wheezy HVMs. For debugging to work, SELinux and stubdoms need to be turned off. Stubdoms are disabled in the Advanced tabs for the VMs. To disable SELinux, run a terminal as root, use <code>nr</code> to log into the admin role then run <code>rw</code> to make the rootfs read-write. Next edit <code>/etc/selinux/config</code> and set <code>SELINUX=permissive</code> and save. Reboot.</p><h2>Building the Kernel</h2><p>The KGDB debugger components need to be enabled in the target kernel. This requires building a custom kernel. On the target, get the kernel source package - in this case for Wheezy:</p><pre><code>$ sudo apt-get install linux-source-3.2\n</code></pre><p>This drops off a tarball <code>/usr/src/linux-source-3.2.tar.bz2</code>. Make a directory called<code>~/kernel</code> and extract the tarball there. Change to <code>~/kernel/linux-source-3.2</code> that has the kernel sources.</p><p>Next the kernel sources need a configuration file. The simplest thing is to start with the one for the currently installed Wheezy kernel. Copy <code>/boot/config-3.2.0-4-amd64</code> as <code>.config</code> in the current sources dir (note the current config file might have a different name). These are the setting that should be enabled/disabled in the <code>.config</code>:</p><pre><code># CONFIG_DEBUG_RODATA is not set\nCONFIG_DEBUG_INFO=y\nCONFIG_FRAME_POINTER=y\nCONFIG_KGDB=y\nCONFIG_KGDB_SERIAL_CONSOLE=y\n</code></pre><p>Briefly, these are the base set of kernel debug features that need to be modified. CONFIG_DEBUG_RODATA marks the .text section RO and prevent KGDB from emitting break-point instruction in the code. CONFIG_DEBUG_INFO enables debug information/symbolic data in the kernel image. CONFIG_FRAME_POINTER preserves stack frame pointers makes stack back-tracing and changing frames easier. The last two enable the KGDB debugger extensions using a serial console.</p><p>Though you can edit <code>.config</code>, it is usually done using one of the editing interfaces. Using <code>make menuconfig</code>, the setting are here:</p><ul><li>\"Kernel hacking\"<ul><li>\"Compile the kernel with debug info\"</li><li>\"Compile the kernel with frame pointers\"</li><li>\"KGDB: kernel debugger ---&gt;\"</li><li>\"KGDB: use kgdb over the serial console\"</li><li>\"Write protect kernel read-only data structures\"</li></ul></li></ul><p>Other debugging features may be enabled/disabled at this point too. It is also recommended that a local version suffix is used for the kernel name to help identify the build. Under \"General setup\" enter a suffix in \"Local version\" (.e.g. \"-kgdb\"). Once all this is done, save the configuration and:</p><pre><code>$ make deb-pkg\n</code></pre><p>This will produce 3 packages in the <code>~/kernel</code> dir:</p><ul><li>linux-image-3.2.65-kgdb_3.2.65-kgdb-1_amd64.deb</li><li>linux-headers-3.2.65-kgdb_3.2.65-kgdb-1_amd64.deb</li><li>linux-libc-dev_3.2.65-kgdb-1_amd64.deb</li></ul><h2>Installing the Kernel</h2><p>This is straight forward, simply install the .deb packages:</p><pre><code>$ sudo dpkg -i linux-image-3.2.65-kgdb_3.2.65-kgdb-1_amd64.deb\n$ sudo dpkg -i linux-headers-3.2.65-kgdb_3.2.65-kgdb-1_amd64.deb\n</code></pre><p>This will create a several files in <code>/boot</code> that can be identified by the local version suffix used (the kernel image, copy of the config, initramfs and system map) and install the modules to<code>/lib/modules</code> as expected. The grub boot loader config will also be updated. The headers will end up under <code>/usr/src</code>.</p><p>The new kernel will need a couple of kernel command line parameters to tell KGDB how to connect over serial. Edit <code>/etc/default/grub</code> and set <code>GRUB_CMDLINE_LINUX=\"kgdboc=ttyS0,115200 kgdbcon\"</code>. Note if there were already values set, the KGDB ones can be appended. Then update grub and reboot:</p><pre><code>$ sudo update-grub; reboot</code></pre><h2>Setup the Debugger</h2><p>In the host VM, first install the debugger with <code>apt-get install gdb</code>. Next the host needs to have the built kernel sources from the target for GDB to work on. The best way to get this (and to synchronize further changes) is to just rsync it. Create a <code>~/kernel</code> dir and sync up the sources and build output:</p><pre><code>$ rsync -avzh myuser@mytarget:~/kernel/linux-source-3.2 ~/kernel\n</code></pre><p>The host is now ready to do some debugging stuffs. The last step is to connect the emulated serial ports from the two VMs.</p><h2>Connecting Serial Ports</h2><p>The emulated serial ports in QEMU can be setup to pipe their communications over TCP/IP - this is how the two VMs will be connected. This could be done either way but in this example the emulated serial port for the host VM will be the listening end and the target will connect. The next steps need to be done in a terminal in dom0 as root. Run this to setup the host VM:</p><pre><code>$ xec-vm -n &lt;host-vm-name&gt; set extra-xenvm \"serial=tcp::4545,server,nowait\"\n</code></pre><p>And this to setup the target:</p><pre><code>$ xec-vm -n &lt;target-vm-name&gt; set extra-xenvm \"serial=tcp:0.0.0.0:4545\"\n</code></pre><p>The port is arbitrary but 4545 works just fine. Now, since the host is the listening side, it needs to be started first, then the target. It could be reversed if need be. Start them both up.</p><h2>Remote Kernel Debugging</h2><p>Everything is in place to do some actual debugging. To ready the target, the kernel execution must be halted and ready to receive a connection from the debugger this is done two ways. One is to add the <code>kgdbwait</code> parameter to the kernel command line in addition to the parameter that were added earlier. More on that parameter can be found in the KGDB documentation. The second which will be used here is to use the magic of sysrq. In the target VM, open a terminal as root and:</p><pre><code>$ echo g &gt; /proc/sysrq-trigger\n</code></pre><p>The VM will freeze and the kernel is now waiting for a debugger connection. Over in the host VM, open a terminal as root and cd to the location of the kernel sources (e.g.<code>/home/myuser/kernel/linux-source-3.2</code>). Start the debugger:</p><pre><code>$ gdb ./vmlinux\n</code></pre><p>This will load the kernel image and symbols. At the GDB command prompt, connect to the remote target VM:</p><pre><code>(gdb) set remotebaud 115200\n(gdb) target remote /dev/ttyS0\n</code></pre><p>Unless something is wrong, GDB should now be connected and in control of the remote kernel. Run a command like <code>bt</code> to see a stack back-trace of where the kernel is waiting for GDB. Refer to the GDB documentation for further commands. To let the kernel resume in the target, type <code>c</code>. The <code>sysrq-trigger</code> can then be used to break to the debugger again.</p><p>Modifications can be made to the kernel image on the target, the changes can be rsync'd to the host. Then the target can be rebooted and kernel debugging can be resumed.</p><h2>Modules and a Practical Example</h2><p>The instructions above are for debugging the kernel image itself. This would be the core guts of the the kernel and any built-in modules. While this is good, being able to debug external modules is quite useful too. A practical example of building one of the OpenXT PV Linux (in this case xc-v4v.ko) drivers will be used to show how to debug a module.</p><p>All of the information above is still applicable but to debug modules, a bit more is needed. The following wiki contains instructions for building the OpenXT PV Linux drivers - this should be read first as background information:</p><p><ac:link><ri:page ri:content-title=\"PV Linux Drivers\" ri:version-at-save=\"5\"></ri:page></ac:link></p><p>On the target, after following those directions and rebooting, the OpenXT PV Linux drivers will be ready including several that will be loaded at boot time. Running <code>sudo lsmod</code> shows the xenbus driver xc-xen, the block and the net front drivers loaded. Others like xc-v4v.ko need to be manually loaded.</p><p>Assume for the example as with above, the same user has the drivers checked out in <code>~/pv-linux-drivers.git</code>. Some fixes have been made to xc-v4v.ko and it was rebuilt in place using make. The built kernel module can be copied to the dkms modules location:</p><pre><code>$ sudo cp ~/pv-linux-drivers.git/xc-v4v/xc-v4v.ko /lib/modules/3.2.65-kgdb/updates/dkms\n</code></pre><p>Note that \"kgdb\" in the path is simply the example local version from above. Now the new driver is in place, the code for the drivers including the local changes on the target need to be sync'd with the host VM so it has access to the binaries, symbols and source. Do this with rsync again:</p><pre><code>$ rsync -avzh myuser@mytarget:~/pv-linux-drivers.git ~/\n</code></pre><p>Finally load the module:</p><pre><code>$ sudo modprobe xc_v4v\n</code></pre><p>If all goes well and the changes did not bring down the target VM, <code>sudo lsmod</code> should show xc_v4v loaded.</p><h2>Debugging Modules</h2><p>The trick with debugging modules is telling GDB where exactly the module got loaded in kernel space. More specifically it is telling GDB where specific sections of the module are loaded. The first step is determining that. In a terminal on the target with the xc-v4v.ko module loaded do:</p><pre><code>$ ls -al /sys/module/xc_v4v/sections\n</code></pre><p>Note the section names tend to start with a '.' so they get treated as hidden. The output should look like this:</p><ac:structured-macro ac:macro-id=\"3bc7e511-1ed4-4c54-a54d-1b27f8dafee3\" ac:name=\"code\" ac:schema-version=\"1\"><ac:parameter ac:name=\"language\">text</ac:parameter><ac:plain-text-body><![CDATA[-r--r--r-- 1 root root 4096 Feb  8 15:59 .bss\n-r--r--r-- 1 root root 4096 Feb  8 15:58 __bug_table\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .data\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .devexit.text\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .devinit.text\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .exit.text\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .gnu.linkonce.this_module\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .init.text\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .note.gnu.build-id\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .rodata\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .rodata.str1.1\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .smp_locks\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .strtab\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .symtab\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .text\n-r--r--r-- 1 root root 4096 Feb  8 15:59 .text.unlikely]]></ac:plain-text-body></ac:structured-macro><p>This is the list of all the sections from the ELF binary module that were loaded. The debugger needs to know where <code>.text</code> is. Optionally other sections can be specified too. For the example, <code>.data</code> and <code>.bss</code> are also going to be specified. The sysfs files for the sections report their base address in kernel space:</p><pre><code>$ cat /sys/module/xc_v4v/sections/.text\n0xffffffffa0395000\n$ cat /sys/module/xc_v4v/sections/.data\n0xffffffffa039a000\n$ cat /sys/module/xc_v4v/sections/.bss\n0xffffffffa039a3e0\n</code></pre><p>Those addresses are needed on the host for GDB. Follow the steps above to get GDB connected to the target. Now within GDB, the symbols for xc-v4v.ko can be added to the base set of symbols the debugger knows about for the <code>vmlinux</code> image. To add the symbols:</p><pre><code>(gdb) add-symbol-file /home/myuser/pv-linux-drivers.git/xc-vusb/xc-vusb.ko 0xffffffffa0395000 -s .data 0xffffffffa039a000 -s .bss 0xffffffffa039a3e0\n</code></pre><p>A friendly message should say the symbols were loaded. The debugger now knows what is where in xc-v4v.ko. Again the GDB docs should be consulted on actually using the debugger.</p><p>One final note. To ensure the symbolic information is present in the kernel components that will be debugged, make sure that these are built using the <code>-g</code> gcc flag. In addition, turning optimization down or off often makes debugging easier. Turning them off can be done by setting the gcc flag <code>-O0</code>. Another handy flag that makes the stack easier to work with is <code>-fno-omit-frame-pointer</code> making function calls save the stack frames and pointers. So for example the modified line for the <code>Makefile</code> in <code>pv-linux-drivers.git</code> looks like:</p><pre><code>$ make -C $(KDIR) FROM_DKMS=n NOSTDINC_FLAGS=\"$(ENOSTDINC_FLAGS)\" M=$(CURDIR) modules EXTRA_CFLAGS=\"-g -O0 -fno-omit-frame-pointer\"\n</code></pre><p>Good luck debugging...</p><h2>Serial Console Tracing</h2><p>Or you may not want to do any of that complicated mess above and you just want to have serial from the guest trace to a console. This does not involve building kernels or any of that.</p><p>First the kernel will need a command line parameter to configure the serial port. Edit <code>/etc/default/grub</code> and set <code>GRUB_CMDLINE_LINUX=\"console=ttyS0,115200n8\"</code>. Note if there were already values set, the serial one can be appended. Then update grub and reboot:</p><pre><code>$ sudo update-grub; poweroff\n</code></pre><p>Next the emulated QEMU serial port is setup to redirect the kernel trace to another host:</p><pre><code>$ xec-vm -n &lt;target-vm-name&gt; set extra-xenvm \"serial=tcp:&lt;ip-of-host-to-trace-to&gt;:3535\"\n</code></pre><p>Finally on the host where the trace is being sent, run netcat in a terminal:</p><pre><code>$ nc -l -p 3535\n</code></pre><p>When the guest starts, the kernel will trace in this terminal. This assumes stubdoms are turned off. To do this with stubdoms enabled, follow the instructions here:</p><p><a href=\"https://openxt.atlassian.net/wiki/display/DC/Windows+HVM+Debugging#WindowsHVMDebugging-DebuggingwithStubdomsEnabled\">Debugging With Stubdoms Enabled</a></p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}