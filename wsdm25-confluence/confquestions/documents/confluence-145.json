{
    "id": "confluence-145",
    "title": "SELinux Main Page",
    "url": "https://openxt.atlassian.net/wiki/spaces/DC/pages/26214412/SELinux+Main+Page",
    "content": "<p>Owned by Ross Philipson\nLast updated: Oct 02, 2018 by Tim Konick\n\n</p><p class=\"auto-cursor-target\"><br/></p><ac:structured-macro ac:macro-id=\"8b686237-640b-4a99-aad7-c28571c6b798\" ac:name=\"info\" ac:schema-version=\"1\"><ac:parameter ac:name=\"icon\">None</ac:parameter><ac:rich-text-body><p><ac:image ac:width=\"80\"><ri:attachment ri:filename=\"cc-by.png\" ri:version-at-save=\"1\"></ri:attachment></ac:image></p><p>Copyright 2013 by Citrix Systems, Inc. This work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy of this license, visit <a class=\"external-link\" href=\"http://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\">http://creativecommons.org/licenses/by/4.0/</a>.</p></ac:rich-text-body></ac:structured-macro><p><ac:structured-macro ac:macro-id=\"6b9ac94f-d045-47c2-a47f-d0342dc6f5d8\" ac:name=\"toc\" ac:schema-version=\"1\"></ac:structured-macro></p><h2>Introduction</h2><p>It's been decided that SELinux has to be fully integrated in to OpenXT's predecessor.</p><p>For that, it needs a policy governing every action that every program can do.</p><p>This is hardly a job for a one-man-army ;-), so every developer needs to be able to write policy bits for their code.</p><p>This document intends to help you dealing with it.</p><h2><span class=\"mw-headline\">SEWhat?</span></h2><p>SELinux consists of a number of cooperating technologies. Firstly the SELinux policy is written in a language based on <a class=\"external text\" href=\"http://en.wikipedia.org/wiki/Type_enforcement\" rel=\"nofollow\">Type Enforcement (TE)</a>. There have been a number of additions to TE in the current <a class=\"external text\" href=\"http://selinuxproject.org/page/PolicyLanguage\" rel=\"nofollow\">policy language</a> to support things like MLS/MCS and generic constraints.</p><p>Second the Linux Kernel was modified to add access control hooks to code paths accessing kernel objects. These hooks were generalized into the Linux Security Modules (LSM) so as to allow any security model to play in the kernel. There are however very few LSM modules and SELinux has become \"the one true LSM\".</p><p>Third is the reference policy (refpol) which is \"the one true policy\" maintained by the community. It's more than just a policy though. There is a build system (it's horrible Makefiles and M4 macros) that provides a rough set of interfaces and some encapsulation as well. Despite all of it's shortcomings though it works quite well.</p><p>Lastly there is a set of userland tools for managing SELinux. This includes stuffs like the policy compiler, the module linker and utilities to perform management tasks like changing the current enforcement mode (permissive vs enforcing). In permissive mode, SELinux will just print what it would have denied in the console. It will <strong>NEVER</strong> actually block <strong>ANYTHING</strong> in this mode. Really, <strong>NEVER</strong>. In enforced mode, it will also actually blocks actions.</p><p>A good summary of SELinux history can be found here: <a class=\"external free\" href=\"https://www.ibm.com/developerworks/library/l-secure-linux-ru/\" rel=\"nofollow\">https://www.ibm.com/developerworks/library/l-secure-linux-ru/</a></p><h2><span class=\"mw-headline\">In OpenXT's Predecessor</span></h2><p>For now, SELinux is present in dom0 and ndvm, and as of the latest Spindrift release it is enforced from first boot in a Kent installation, permissive for all the other cases.</p><p>The default behaviour is defined in \"/etc/selinux/config\".</p><p>You can get the current SELinux state of a VM by running <code>getenforce</code>.</p><p>You can set the current SELinux state of a VM by running <code>setenforce</code>, followed by 0 for Permissive, 1 for Enforcing.</p><p>SELinux is also used to separate QEMU processes from each other using an architecture known as sVirt. Our implementation of sVirt is documented in the OpenXT's predecessor sVirt page.</p><h2><span class=\"mw-headline\">How it works</span></h2><p>SELinux is built on the notion of contexts.</p><p>They are two main types of contexts, the file context and the processes context.</p><p>Most of the rules define what process contexts can do to file contexts.</p><p>SELinux is built on a deny-by-default base. So you'll need to have rules for everything!</p><h2><span class=\"mw-headline\">The rules</span></h2><p>The SELinux rules are located in the OpenXT's predecessor git repository selinux-policy.</p><p>They are divided in modules, stored in policy/modules, and activated by policy/modules.conf.</p><p>Usually, a module represents a program.</p><p>A module is divided in 3 files :</p><p>- module.fc: This file defines the SELinux contexts of the files that belongs to the module.</p><p>- module.te: This file is a list of rules. It is generally the list of thing that the program can do.</p><p>- module.if: This file is used to define higher-level interfaces for another module to interact with it. Using the interfaces is strongly recommended, as it allows the policy to evolve more easily, makes rules way more clear and gives a very agreeable abstraction level.</p><h2><span class=\"mw-headline\">Writing a rule</span></h2><p>So you added a new feature to your program and now SELinux complains? Here is what you should do :</p><p>First, you need to be in Permissive mode before running your program. Otherwise, SELinux could block it to early to trigger all the denials.</p><p>Then, get the errors from the logs, those are called AVCs in the SELinux dialect. You can for example try <code>grep avc /var/log/messages | grep &lt;program&gt;</code>, to get &lt;program&gt;'s denials.</p><p>Let's for example say that you just added V4V communications to the program fish. <code>grep avc /var/log/messages | grep fish,</code> gives you :</p><pre>[...] avc:  denied  { open } for  pid=131 comm=\"fish\" path=\"/dev/v4v_stream\" dev=tmpfs ino=3626 scontext=system_u:system_r:fish_t:s0 tcontext=system_u:object_r:v4v_t:s0 tclass=chr_file\n[...] avc:  denied  { read } for  pid=131 comm=\"fish\" path=\"/dev/v4v_stream\" dev=tmpfs ino=3626 scontext=system_u:system_r:fish_t:s0 tcontext=system_u:object_r:v4v_t:s0 tclass=chr_file\n[...] avc:  denied  { write } for  pid=131 comm=\"fish\" path=\"/dev/v4v_stream\" dev=tmpfs ino=3626 scontext=system_u:system_r:fish_t:s0 tcontext=system_u:object_r:v4v_t:s0 tclass=chr_file\n</pre><p>So you need to open policy/apps/fish.te, then there are 3 ways to write the rules allowing fish to do V4V.</p><h3><span class=\"mw-headline\">The \"seriously dude? come on!\" solution</span></h3><p>For this awful (but so easy...) solution, you take the denials and translate them into SELinux raw rules :</p><pre>allow fish_t v4v_t:chr_file { open };\nallow fish_t v4v_t:chr_file { read };\nallow fish_t v4v_t:chr_file { write };\n</pre><p>You paste that into fish.te, job done.</p><p>If you are bad enough to do that, please at least add the value of \"path\" (\"/dev/v4v_stream\" here) in a comment (or even the entire denial), so that you we clean-up after you!</p><h3><span class=\"mw-headline\">The least effort solution</span></h3><p>You decided to be just a bit kind with the policy maintainers, thank you!</p><p>SELinux has a lot of macros available for usual actions.</p><p>They are not always easy to find, but the folder policy/support is a good place to start from.</p><p>For our example, there is a macro in \"policy/support/obj_perm_sets.spt\": <code>define('rw_chr_file_perms',{ getattr open read write append ioctl lock })</code></p><p>Let's use it! You can now write :</p><pre>allow fish_t v4v_t:chr_file { rw_chr_file_perms };\n</pre><p>OK, this is a bit better, but we still don't really know the exact thing your program wants to do, so again, please add a comment with at least the value of \"path\"</p><h3><span class=\"mw-headline\">The Best solution</span></h3><p>So you really want to be a good man today? Awesome!</p><p>As said before, when writing SELinux policies, interfaces should be used.</p><p>Let's check what we've got for V4V...</p><p>...[a few greps later]...</p><p>\"policy/modules/system/xc_files.if\" defines the interface <code>xc_files_rw_v4v_chr</code>, which take one argument : the source context.</p><p>As WE are the source context, the rule can be written like this :</p><pre>xc_files_rw_v4v_chr(fish_t)\n</pre><p>And this is a sexy and meaningful SELinux rule!</p><p>This type of rule usually makes more sense when read, but more importantly, it will cover denials that you would have had in the future (if a file becomes a symlink for example).</p><p>So keep in mind that writing good rules will save you time in the future!!</p><h2><span class=\"mw-headline\">Creating a module</span></h2><p>If you wrote a new program, you'll need an SELinux module for it.</p><p>Start by copying a small existing OpenXT's predecessor module, such as angelomachy, replacing of course the occurrences of \"angelomachy\" by your module name.</p><p>Put a context on your files in the .fc file, write rules as explained before in the .te file, and if your program is designed to be able to receive any kind of communication, you should write interface(s) in the .if file, such as interface(`talk_to_me')!</p>",
    "date": "2024-11-15",
    "disclaimer": "Users of this benchmark dataset are advised to check Atlassian’s official documentation for the most current information.",
    "space": "DC"
}